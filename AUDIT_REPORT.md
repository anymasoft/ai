# ТЕХНИЧЕСКИЙ АУДИТ РЕПОЗИТОРИЕВ ПАРСЕРОВ

**Дата:** 2026-02-14
**Аудитор:** Senior Backend Engineer / Technical Auditor

---

## 1. parser_avito (Duff89/parser_avito)

### Краткое резюме

Наиболее зрелый проект из всей коллекции. Это десктопное GUI-приложение на Flet для парсинга объявлений Avito с уведомлениями в Telegram/VK, экспортом в Excel, поддержкой прокси, фильтрацией и SQLite-хранилищем просмотренных объявлений. Имеет Docker-сборку, CI/CD через GitHub Actions, документацию и систему issue-шаблонов. Код организован с использованием паттернов (фабрики, стратегии, composite). Это реально рабочий инструмент, а не демо.

### Архитектурная оценка

**Структура проекта (~30 файлов Python):**
```
AvitoParser.py          — GUI (Flet), точка входа
parser_cls.py           — основная логика парсинга (класс AvitoParse)
models.py               — Pydantic-модели данных Avito
dto.py                  — dataclass-ы конфигурации
db_service.py           — SQLite (singleton)
filters/ads_filter.py   — конвейер фильтров
parser/http/client.py   — HTTP-клиент с ретраями и обработкой блокировок
parser/proxies/          — абстракция прокси (NoProxy, ServerProxy, MobileProxy)
parser/cookies/          — провайдер cookies (внешний API spfa.ru)
parser/export/           — экспорт (Excel, с фабрикой и нейминг-стратегиями)
integrations/notifications/ — уведомления (Telegram, VK, Composite, NullNotifier)
load_config.py          — загрузка TOML-конфига
Dockerfile, docker-compose.yml, Makefile
```

1. **Организация:** Есть чёткое разделение: HTTP-клиент, прокси, cookies, экспорт, уведомления, фильтры — всё в отдельных модулях. Используются абстрактные базовые классы (ABC), фабричные функции, Composite-паттерн для уведомлений. Это уже не «скрипт», а проект с архитектурой.

2. **Масштабируемость:** Можно добавить новый тип экспорта (CSV, API), новый мессенджер, новый тип прокси — через реализацию ABC. Фильтры — конвейерные, легко расширяемы. **Оценка: хорошая.**

3. **Production-readiness:**
   - Обработка ошибок: **есть**, try/except на всех уровнях
   - Логирование: **loguru**, ротация логов (5 MB, 5 дней)
   - Ретраи: **есть** — HTTP-клиент с max_retries, backoff для уведомлений
   - Анти-блок: **есть** — обработка 401/403/429, подсчёт блоков, сброс cookies через внешний API (spfa.ru), смена IP для мобильных прокси
   - Прокси: **полноценная поддержка** — серверные и мобильные, со сменой IP
   - Rate limiting: **частично** — пауза между ссылками и между повторами

4. **Костыли:**
   - `time.sleep` в циклах — **есть, но осознанные** (пауза между запросами, rate limiting)
   - `DEBUG_MODE = False` с `open("december.txt")` — отладочный костыль оставлен в коде
   - `from lang import *` — wildcard import, плохая практика
   - GUI-код (500+ строк) в одном файле `AvitoParser.py` — не разделён на компоненты
   - `SQLiteDBHandler` — singleton через `__new__`, нестандартный подход
   - Таблица `viewed` без индексов — будет тормозить при больших объёмах

5. **Рабочий парсер или демо?** Это **реально рабочий парсер**. Парсит HTML-страницы Avito (извлекает JSON из `<script type="mime/invalid">`), поддерживает пагинацию, фильтрует, уведомляет, сохраняет. Использует httpx + playwright (опционально). Есть интеграция с внешним сервисом обхода блокировок (spfa.ru).

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **7/10** |
| Архитектура | **7/10** |
| Надёжность | **6/10** |
| Расширяемость | **7/10** |
| Пригодность как база для SaaS | **5/10** |

### Коммерческая оценка

- **Можно ли использовать как основу коммерческого продукта?** Частично. Архитектурные абстракции пригодны. HTTP-клиент, система фильтров, экспорт, уведомления — можно взять как каркас.
- **Дешевле написать с нуля?** Нет, дешевле рефакторить. ~40-50% кода реально пригодно.
- **Уровень:** Крепкий MVP. Не «студенческая поделка» — видно опыт, но до production SaaS далеко.

### Технические проблемы
- GUI смешан с бизнес-логикой в одном файле (500+ строк)
- Нет тестов вообще
- `from lang import *` — wildcard import
- Отладочный `DEBUG_MODE` жёстко в коде
- SQLite без индексов, без миграций
- Нет async — всё синхронное на потоках
- Нет конфигурации через env-переменные (только TOML)
- `self.stop_event = True` (строка 151 parser_cls.py) вместо `self.stop_event.set()` — баг
- Захардкоженный токен в `TOKEN` у спутниковых скриптов

### Что можно использовать
- Архитектура HTTP-клиента с ретраями и обработкой блокировок
- Система фабрик (прокси, cookies, экспорт, уведомления)
- Конвейер фильтров
- Pydantic-модели данных Avito
- Логика извлечения JSON из HTML Avito

### Что нужно переписать
- GUI → отделить от логики, либо заменить на web-интерфейс
- SQLite → PostgreSQL с миграциями
- Синхронный код → async (aiohttp/httpx async)
- Добавить тесты
- Убрать отладочные костыли
- Добавить API-слой, если делать SaaS

### Итоговый вердикт

**parser_avito — единственный проект из шести, который имеет реальную архитектурную ценность.** Видна эволюция от скрипта к инструменту: абстракции, фабрики, конвейеры фильтров, поддержка прокси, ретраи, обход блокировок через внешний API. Однако это десктопный GUI-инструмент, а не SaaS-бэкенд. Для превращения в коммерческий продукт потребуется: выделение бэкенда из GUI, переход на async, добавление API, замена SQLite на нормальную БД и написание тестов. Тем не менее, ~40-50% кода реально пригодно, и это дешевле, чем писать с нуля.

---

## 2. wb_rank (Duff89/wb_rank)

### Краткое резюме

Минималистичный скрипт из 3 файлов для определения позиции товара в поиске Wildberries + расчёт цены с учётом WB-кошелька. Без архитектуры, без тестов, с захардкоженным токеном прямо в коде. Использует SeleniumBase для получения cookies.

### Архитектурная оценка

**Структура проекта (3 файла Python):**
```
get_rank.py                   — основная логика поиска позиции
get_token.py                  — получение cookies через SeleniumBase (headless)
get_price_with_wb_wallet.py   — расчёт цены с WB-кошельком
```

1. **Организация:** Плоская структура, 3 файла. Нет разделения слоёв. Это именно «набор скриптов».

2. **Масштабируемость:** Минимальная. Класс `WbRank` принимает список товаров — это хорошо. Но всё остальное захардкожено (URL, параметры запроса, токен).

3. **Production-readiness:**
   - Обработка ошибок: **частичная** — есть try/except в get_price_with_wb_wallet, но в get_rank слабая
   - Логирование: **loguru**, но без ротации
   - Ретраи: **примитивные** — 2 попытки в get_fetch при 498
   - Прокси: **нет**
   - Rate limiting: **нет**
   - Анти-блок: **примитивный** — обновление токена через selenium при 498

4. **Костыли:**
   - **`TOKEN = '1.1000.a133f...'`** — ЗАХАРДКОЖЕННЫЙ РЕАЛЬНЫЙ ТОКЕН прямо в коде (критическая проблема безопасности!)
   - `time.sleep(5)` в цикле получения cookies
   - `x-spa-version: 13.15.1` — захардкоженная версия, протухнет
   - `dest: -3626404` — магическое число
   - Нет `.env` для секретов

5. **Рабочий парсер или демо?** Рабочий скрипт, но **хрупкий**. Зависит от внутренних API WB (`__internal/u-search`), которые могут измениться в любой момент. Selenium для получения токена — тяжёлый подход.

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **6/10** |
| Архитектура | **3/10** |
| Надёжность | **3/10** |
| Расширяемость | **2/10** |
| Пригодность как база для SaaS | **2/10** |

### Коммерческая оценка

- **Можно ли использовать как основу?** Нет. Это утилитарный скрипт.
- **Дешевле написать с нуля?** Однозначно да. Логики здесь на 2-3 часа работы.
- **Пригодно:** ~15% (общая идея API-запроса к WB).
- **Уровень:** Между студенческой поделкой и черновиком утилиты.

### Технические проблемы
- Захардкоженный токен в открытом виде
- Захардкоженные параметры запроса
- Нет прокси-поддержки
- Нет асинхронности (при обработке сотен товаров будет медленно)
- `get_rank_position` получает тип `json` вместо `dict` — некорректная аннотация
- SeleniumBase как тяжёлая зависимость для получения 1 cookie

### Что можно использовать
- Логика определения позиции товара в поиске (алгоритм)
- Формула расчёта цены с WB-кошельком (`get_price_with_wb_wallet.py` — неплохой)

### Что нужно переписать
- Всё, кроме бизнес-логики расчёта цены

### Итоговый вердикт

**wb_rank — утилитарный скрипт, не имеющий архитектурной ценности.** Захардкоженный токен в открытом коде, отсутствие прокси, зависимость от внутренних API Wildberries, тяжёлый SeleniumBase для одной cookie — всё это делает код непригодным для коммерческого использования. Единственная ценность — знание эндпоинтов WB и формула расчёта цены. Дешевле написать с нуля.

---

## 3. wb_smart_review (Duff89/wb_smart_review)

### Краткое резюме

GUI-приложение на Flet, которое собирает отзывы с Wildberries и отправляет их в ChatGPT для формирования списка плюсов/минусов товара. 3 файла Python. Использует g4f (бесплатный GPT-прокси) как фолбэк. Код примитивный, без обработки ошибок.

### Архитектурная оценка

**Структура проекта (3 файла Python):**
```
main.py       — GUI (Flet)
wb.py         — парсинг отзывов с WB
chat_gpt.py   — отправка в GPT (OpenAI API + g4f)
```

1. **Организация:** Плоская. Три файла, каждый по ~70 строк. Ни слоёв, ни абстракций.

2. **Масштабируемость:** Нулевая. Всё захардкожено. Чтобы добавить другой маркетплейс — придётся переписать.

3. **Production-readiness:**
   - Обработка ошибок: **отсутствует** в критических местах. `wb.py:50` — голый `response.json()["data"]["products"][0]["root"]` без проверок. Любой сбой = крэш.
   - Логирование: `print()` вместо логгера
   - Ретраи: **нет**
   - Прокси: **нет**

4. **Костыли:**
   - `type(text) == str` вместо `isinstance` (main.py:47)
   - Парсинг JSON-ответа GPT через `text.find("{")` — крайне хрупко
   - `base_url="https://api.proxyapi.ru/openai/v1"` — захардкоженный прокси OpenAI
   - `g4f` (бесплатный GPT-прокси) — нестабилен, может упасть в любой момент
   - Магическое число `80` для лимита отзывов
   - `raise Exception("Сервер 1 не подошел")` — used для control flow

5. **Рабочий парсер или демо?** Скорее **демо/PoC**. Работает, пока WB не сменит API. GPT-интеграция хрупкая (парсинг ответа через `find`).

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **5/10** |
| Архитектура | **2/10** |
| Надёжность | **2/10** |
| Расширяемость | **1/10** |
| Пригодность как база для SaaS | **1/10** |

### Коммерческая оценка

- **Можно ли использовать как основу?** Нет. Это прототип на 1 вечер.
- **Дешевле написать с нуля?** Безусловно. Здесь ~150 строк кода.
- **Пригодно:** ~5% (идея использовать GPT для анализа отзывов).
- **Уровень:** Студенческая поделка / демо для YouTube.

### Технические проблемы
- Нет обработки ошибок API
- Парсинг JSON через `find("{")` — сломается на вложенных структурах
- `g4f` — сомнительная зависимость, нарушающая ToS OpenAI
- Нет кэширования отзывов
- Нет поддержки нескольких товаров
- Нет прокси

### Что можно использовать
- Эндпоинты WB для получения отзывов (`feedbacks1.wb.ru`, `feedbacks2.wb.ru`)
- Идея GPT-анализа отзывов (но реализовать надо заново)

### Что нужно переписать
- Всё

### Итоговый вердикт

**wb_smart_review — демонстрационный прототип.** Интересная идея (GPT-суммаризация отзывов WB), но реализация примитивна: нет обработки ошибок, хрупкий парсинг ответа GPT, использование сомнительного g4f, отсутствие любых абстракций. Коммерческой ценности нет. Идею стоит взять, код — нет.

---

## 4. SimpleProxyChecker (Duff89/SimpleProxyChecker)

### Краткое резюме

Утилита для проверки прокси: определяет протокол (HTTP/SOCKS4/SOCKS5), скорость, уровень анонимности (Transparent/Anonymous/High) и геолокацию. Один файл, один класс, ~85 строк. Рабочий, но примитивный.

### Архитектурная оценка

**Структура проекта (1 файл Python):**
```
main.py — весь код
```

1. **Организация:** Монолитный скрипт. Один класс, вся логика внутри.

2. **Масштабируемость:** Минимальная. Проверяет по одному прокси. Нет многопоточности, нет пакетной обработки.

3. **Production-readiness:**
   - Обработка ошибок: `except Exception: pass` — **молчаливое проглатывание ошибок**
   - `except:` (bare except, строка 77) — **антипаттерн**
   - Логирование: **нет**
   - Ретраи: **нет**

4. **Костыли:**
   - `except Exception: pass` — везде
   - `except:` (bare except)
   - Магическое число `10` (таймаут)
   - `dict or bool` как аннотация возвращаемого типа — синтаксически неправильно
   - Мутация `self.result_dict` через side-effect

5. **Рабочий или демо?** Рабочий для единичных проверок. Не масштабируется.

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **5/10** |
| Архитектура | **2/10** |
| Надёжность | **2/10** |
| Расширяемость | **2/10** |
| Пригодность как база для SaaS | **1/10** |

### Коммерческая оценка

- **Можно ли использовать как основу?** Нет.
- **Дешевле написать с нуля?** Да. Это 85 строк кода.
- **Пригодно:** ~10% (список judge-серверов и логика определения анонимности).
- **Уровень:** Учебный скрипт.

### Технические проблемы
- Bare except
- Молчаливое проглатывание ошибок
- Нет async/многопоточности для пакетных проверок
- Устаревшие judge-серверы (могут быть недоступны)
- Нет логирования
- Некорректные type hints

### Что можно использовать
- Алгоритм определения уровня анонимности прокси (заголовки VIA, X-FORWARDED-FOR и т.д.)

### Что нужно переписать
- Всё

### Итоговый вердикт

**SimpleProxyChecker — учебный скрипт, не имеющий коммерческой ценности.** 85 строк кода без логирования, с bare except, без многопоточности. Единственное полезное — алгоритм определения анонимности прокси. Писать с нуля быстрее, чем рефакторить.

---

## 5. wildberries_parser (Duff89/wildberries_parser)

### Краткое резюме

Парсер каталога продавца на Wildberries: собирает информацию о товарах (id, название, цена, бренд, рейтинг, изображения, отзывы) и сохраняет в CSV. Один основной класс, Pydantic-модели. ~100 строк основной логики.

### Архитектурная оценка

**Структура проекта (2 файла Python):**
```
parser.py   — основная логика парсинга
models.py   — Pydantic-модели
```

1. **Организация:** Минимальная, но чистая. Модели отделены от логики — это плюс.

2. **Масштабируемость:** Ограничена. Парсит только каталог одного продавца. Захардкоженные URL и параметры (`dest=-1257786`).

3. **Production-readiness:**
   - Обработка ошибок: **отсутствует**. Ни одного try/except. Любой сбой = крэш.
   - Логирование: **нет**
   - Ретраи: **нет**
   - Прокси: **нет**

4. **Костыли:**
   - Захардкоженные `basket_ranges` — магические числа для формирования URL изображений (но это специфика WB, иначе нельзя)
   - `dest=-1257786` — магическое число
   - CSV-файл перезаписывается при каждом запуске
   - Запрос отзывов по каждому товару — **N+1 запрос без пауз и ретраев**
   - `while True` без ограничения страниц

5. **Рабочий или демо?** Рабочий скрипт для одноразового сбора данных. Использует публичные API WB (не HTML-парсинг), что снижает хрупкость.

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **6/10** |
| Архитектура | **3/10** |
| Надёжность | **2/10** |
| Расширяемость | **2/10** |
| Пригодность как база для SaaS | **2/10** |

### Коммерческая оценка

- **Можно ли использовать как основу?** Нет.
- **Дешевле написать с нуля?** Да.
- **Пригодно:** ~20% (Pydantic-модели и знание API WB).
- **Уровень:** Утилитарный скрипт.

### Технические проблемы
- Полное отсутствие обработки ошибок
- Нет пауз между запросами — риск блокировки
- Нет прокси
- Нет логирования
- N+1 запрос к API отзывов (по запросу на каждый товар)
- Захардкоженный `dest`

### Что можно использовать
- Pydantic-модели товаров WB
- Алгоритм формирования URL изображений WB (`basket_ranges`)
- Знание API WB (card.wb.ru, catalog.wb.ru, feedbacks1.wb.ru)

### Что нужно переписать
- Всё, кроме моделей и знания API-эндпоинтов

### Итоговый вердикт

**wildberries_parser — простой скрипт для одноразового сбора данных.** Нет обработки ошибок, нет пауз, нет прокси. Ценность — в знании API-эндпоинтов Wildberries и алгоритме формирования URL изображений. Это не продукт, а черновик утилиты. Для коммерческого использования нужно писать с нуля, взяв только модели и эндпоинты.

---

## 6. CaptchaSolverExample (Duff89/CaptchaSolverExample)

### Краткое резюме

Коллекция примеров решения капчи с использованием Selenium + rucaptcha (платный сервис). Включает: решение reCAPTCHA v2 через API, решение image-капчи, решение через браузерное расширение, решение reCAPTCHA Enterprise (Steam). Также включено полное расширение для Chrome (captcha-solver). Это **обучающий материал**, а не продукт.

### Архитектурная оценка

**Структура проекта:**
```
driver_chrome.py                 — обёртка над undetected_chromedriver
captcha_extension.py             — пример с расширением
recaptcha_v2.py                  — решение reCAPTCHA v2
recaptcha_callback.py            — решение через callback
recaptcha_enterprise_steam.py    — решение Enterprise (Steam)
image_captcha.py                 — решение image-капчи
vosk_example.py                  — голосовое распознавание (?)
captcha/                         — полное Chrome-расширение для решения капч
```

1. **Организация:** Набор независимых примеров. Нет общей архитектуры.

2. **Масштабируемость:** Не применимо — это примеры, не библиотека.

3. **Production-readiness:** Не применимо.

4. **Костыли:**
   - `time.sleep(500)` (captcha_extension.py:20) — **500 секунд ожидания!**
   - `time.sleep(100)` (recaptcha_callback.py:57)
   - `time.sleep(20)`, `time.sleep(10)` — повсюду
   - Захардкоженные URL, email, пароли прямо в коде
   - `email_str = 'hazibula64575@rambler.ru'` (recaptcha_enterprise_steam.py:139) — **реальный email в коде**
   - `print(1)`, `print(2)` — отладочные принты
   - Реферальные ссылки rucaptcha повсюду
   - Определение версии Chrome через реестр Windows / subprocess — хрупко
   - `open("user_agent_pc.txt").readlines()` — файл не закрывается

5. **Рабочий или демо?** Это **обучающие примеры** для YouTube-канала. Реферальные ссылки rucaptcha подтверждают это.

### Оценки (1-10)
| Критерий | Оценка |
|---|---|
| Читаемость | **4/10** |
| Архитектура | **1/10** |
| Надёжность | **1/10** |
| Расширяемость | **1/10** |
| Пригодность как база для SaaS | **0/10** |

### Коммерческая оценка

- **Можно ли использовать как основу?** Нет.
- **Дешевле написать с нуля?** Это не продукт. Это обучающий контент.
- **Пригодно:** 0% как код. Ценна идея интеграции с rucaptcha.
- **Уровень:** Обучающий материал / примеры для YouTube.

### Риски
- Решение капчи на чужих сайтах — **юридический риск**
- Автоматическая регистрация Steam — **нарушение ToS**
- Автоматический вход на visa.vfsglobal.com — **нарушение ToS**

### Технические проблемы
- sleep(500) — абсурдное ожидание
- Захардкоженные credentials
- Нет обработки ошибок
- Нет конфигурации
- Chrome extension включён целиком (возможно чужой код)

### Что можно использовать
- Знание API rucaptcha (паттерн интеграции)
- `ChromeBrowser` — обёртка над undetected_chromedriver (нужен серьёзный рефакторинг)

### Что нужно переписать
- Всё. Это не код для повторного использования.

### Итоговый вердикт

**CaptchaSolverExample — обучающий контент для YouTube-канала, а не код для повторного использования.** Реферальные ссылки, захардкоженные credentials, sleep(500), отладочные принты — всё указывает на то, что это примеры для видео-уроков. Коммерческой ценности ноль. Единственное полезное — паттерн интеграции с rucaptcha, который можно реализовать за 1-2 часа.

---

# СВОДНАЯ ТАБЛИЦА

| Репозиторий | Читаемость | Архитектура | Надёжность | Расширяемость | SaaS-пригодность | Вердикт |
|---|---|---|---|---|---|---|
| **parser_avito** | 7 | 7 | 6 | 7 | 5 | **Крепкий MVP, можно рефакторить** |
| **wb_rank** | 6 | 3 | 3 | 2 | 2 | Скрипт, переписать с нуля |
| **wb_smart_review** | 5 | 2 | 2 | 1 | 1 | Демо/PoC, переписать с нуля |
| **SimpleProxyChecker** | 5 | 2 | 2 | 2 | 1 | Учебный скрипт |
| **wildberries_parser** | 6 | 3 | 2 | 2 | 2 | Скрипт, взять только эндпоинты |
| **CaptchaSolverExample** | 4 | 1 | 1 | 1 | 0 | Обучающий контент, не код |

---

# ИТОГОВОЕ ЗАКЛЮЧЕНИЕ

## Можно ли на этом строить прибыльный продукт?

**Короткий ответ: только parser_avito имеет частичную ценность. Остальные 5 репозиториев — скрипты/демо без архитектуры.**

### Что реально можно взять:

1. **Из parser_avito (~40-50% кода):**
   - Архитектура с фабриками и ABC
   - HTTP-клиент с ретраями и обработкой блокировок
   - Система фильтров
   - Система уведомлений (Telegram/VK)
   - Экспорт в Excel
   - Знание структуры данных Avito

2. **Из остальных репозиториев (только знания, не код):**
   - API-эндпоинты Wildberries (search, catalog, feedbacks, card)
   - Формула расчёта цены с WB-кошельком
   - Алгоритм формирования URL изображений WB
   - Паттерн интеграции с rucaptcha
   - Алгоритм определения анонимности прокси

### Что нужно для коммерческого продукта:
- **Async-архитектура** (aiohttp/httpx async) — ни один проект не использует
- **Нормальная БД** (PostgreSQL) — только SQLite без индексов
- **API-слой** (FastAPI/Django) — нет ни в одном проекте
- **Тесты** — ноль тестов во всех 6 репозиториях
- **CI/CD** — только parser_avito имеет базовый
- **Мониторинг и метрики** — нет нигде
- **Очереди задач** (Celery/RQ) — нет
- **Конфигурация через env** — почти нигде

### Финальная оценка:
Перед нами — портфолио разработчика, который двигается от скриптов к архитектуре (parser_avito — это видно). Но **5 из 6 репозиториев — это переупакованные скрипты или обучающий контент для YouTube**. Только parser_avito заслуживает рефакторинга. Для остальных дешевле и правильнее написать с нуля, взяв лишь знание API-эндпоинтов и бизнес-логику.

**Если цель — SaaS для парсинга маркетплейсов, рекомендация: взять parser_avito как отправную точку для архитектурных идей, переписать бэкенд на async FastAPI + PostgreSQL + Celery, а остальные 5 репозиториев использовать исключительно как справочник по API-эндпоинтам WB/Avito.**
