---
import Container from '../components/Container.astro';
import LiveBalance from '../components/LiveBalance.astro';
import AppLayout from '../layouts/AppLayout.astro';
import { getUserFromSession } from '../lib/auth';
import { getDb } from '../lib/db';

// Эта страница должна быть динамичной для работы с middleware и cookies
export const prerender = false;

// Получаем текущего пользователя из сессии
const sessionToken = Astro.cookies.get('session_token')?.value;
const user = sessionToken ? getUserFromSession(sessionToken) : null;

// Если пользователь не авторизован, редиректим на главную
if (!user) {
  return Astro.redirect('/');
}

// Загружаем пакеты из БД
const db = getDb();

const packages = db.prepare(`
  SELECT key, title, price_rub, generations
  FROM packages
  WHERE is_active = 1
  ORDER BY price_rub ASC
`).all() as Array<{key: string; title: string; price_rub: number; generations: number}>;

// Карточки пакетов: Basic, Pro, Enterprise
interface PackageCard {
  key: string;
  name: string;
  description: string;
  price: string;
  credits: number;
  features: string[];
  popular: boolean;
}

const packageCards: PackageCard[] = packages.map((pkg, idx) => {
  const priceRub = pkg.price_rub;
  // Конвертируем в доллары (примерный курс 1 USD ≈ 110 RUB)
  const priceUsd = Math.round(priceRub / 110);

  const featureMap: Record<string, string[]> = {
    basic: [
      `${pkg.generations} кредитов видео`,
      'До 60 секунд',
      'Стандартное качество'
    ],
    pro: [
      `${pkg.generations} кредитов видео`,
      'До 120 секунд',
      'Премиум качество',
      'Приоритетная обработка'
    ],
    enterprise: [
      `${pkg.generations} кредитов видео`,
      'До 300 секунд',
      'Максимальное качество',
      'Приоритетная обработка',
      'Поддержка 24/7'
    ]
  };

  return {
    key: pkg.key,
    name: pkg.title,
    description: idx === 0 ? 'Идеально для проверки возможностей' : idx === 1 ? 'Для серьёзных создателей контента' : 'Для профессионалов',
    price: `${priceRub} ₽`,
    credits: pkg.generations,
    features: featureMap[pkg.key] || featureMap.basic,
    popular: idx === 1 // Средний пакет - самый популярный
  };
});
---

<AppLayout title="Billing - Beem">
	<div class="w-full h-full flex flex-col overflow-hidden">
		<div class="flex-1 flex flex-col overflow-hidden">
			<div class="p-3 md:p-4 w-full h-full overflow-hidden flex flex-col">
				<div class="max-w-5xl mx-auto w-full h-full flex flex-col">
					<!-- Header with Back Button -->
					<div class="flex items-center gap-3 mb-3">
						<!-- Back Button - LEFT -->
						<a href="/app" class="inline-flex items-center justify-center p-1 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 transition cursor-pointer flex-shrink-0">
							<svg class="w-5 h-5 text-gray-700 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
							</svg>
						</a>

						<!-- Title with Live Balance -->
						<div class="text-center flex-1">
							<LiveBalance size="large" />
						</div>
					</div>

					<!-- Packages Grid with Popular Badge -->
					<section class="relative flex-1">
						<!-- Popular Badge - SEPARATE LAYER, NOT part of grid -->
						{packageCards.some(pkg => pkg.popular) && (
							<div class="absolute top-0 left-1/2 -translate-x-1/2 -translate-y-1/2 z-20">
								<div class="bg-primary text-white px-3 py-1 rounded-full text-xs font-semibold whitespace-nowrap shadow-md">
									Популярный
								</div>
							</div>
						)}

						<!-- Pricing Grid - CLEAN cards without badge, direct child of section -->
						<div class={`grid gap-2 h-full ${packageCards.length === 3 ? 'md:grid-cols-3' : 'md:grid-cols-2'}`}>
								{packageCards.map((pkg) => (
									<div class={`border rounded-xl p-3 bg-white dark:bg-gray-800 text-left hover:shadow-lg hover:shadow-gray-600/10 transition flex flex-col h-full ${pkg.popular ? 'border-2 border-primary' : 'border-gray-100 dark:border-gray-700'}`}>
										<h3 class="text-base font-bold text-gray-900 dark:text-white mb-0.5">
											{pkg.name}
										</h3>
										<p class="text-xs text-gray-600 dark:text-gray-300 mb-1">
											{pkg.description}
										</p>
										<p class="text-2xl font-bold text-primary mb-2">
											{pkg.price}
										</p>
										<ul class="space-y-0.5 mb-2 text-gray-600 dark:text-gray-300 flex-1 text-xs">
											{pkg.features.map((feature) => (
												<li class="flex items-center gap-1">
													<span class="text-primary text-xs">✓</span>
													<span>{feature}</span>
												</li>
											))}
										</ul>
										<button
											type="button"
											data-package={pkg.key}
											class="w-full relative flex h-8 items-center justify-center px-4 before:absolute before:inset-0 before:rounded-full before:bg-primary before:transition before:duration-300 hover:before:scale-105 active:before:scale-95 disabled:opacity-50 disabled:cursor-not-allowed package-button"
										>
											<span class="relative text-xs font-semibold text-white">Пополнить</span>
										</button>
									</div>
								))}
						</div>
					</section>

					<!-- Payment Status Message -->
					<div id="payment-status" class="hidden px-3 py-2 rounded-lg text-xs font-medium mt-2"></div>
				</div>
			</div>
		</div>
	</div>
</AppLayout>

<script>
	const statusDiv = document.getElementById('payment-status') as HTMLDivElement;
	const packageButtons = document.querySelectorAll('.package-button') as NodeListOf<HTMLButtonElement>;

	function showStatus(message: string, type: 'success' | 'error' | 'loading') {
		statusDiv.classList.remove('hidden');
		statusDiv.textContent = message;

		// Удаляем старые классы
		statusDiv.classList.remove('bg-green-50', 'dark:bg-green-900/20', 'border-green-200', 'dark:border-green-800', 'text-green-700', 'dark:text-green-400');
		statusDiv.classList.remove('bg-red-50', 'dark:bg-red-900/20', 'border-red-200', 'dark:border-red-800', 'text-red-700', 'dark:text-red-400');
		statusDiv.classList.remove('bg-blue-50', 'dark:bg-blue-900/20', 'border-blue-200', 'dark:border-blue-800', 'text-blue-700', 'dark:text-blue-400');

		// Добавляем новые классы в зависимости от типа
		if (type === 'success') {
			statusDiv.classList.add('bg-green-50', 'dark:bg-green-900/20', 'border', 'border-green-200', 'dark:border-green-800', 'text-green-700', 'dark:text-green-400');
		} else if (type === 'error') {
			statusDiv.classList.add('bg-red-50', 'dark:bg-red-900/20', 'border', 'border-red-200', 'dark:border-red-800', 'text-red-700', 'dark:text-red-400');
		} else if (type === 'loading') {
			statusDiv.classList.add('bg-blue-50', 'dark:bg-blue-900/20', 'border', 'border-blue-200', 'dark:border-blue-800', 'text-blue-700', 'dark:text-blue-400');
		}
	}

	function disableAllButtons() {
		packageButtons.forEach(btn => {
			btn.disabled = true;
		});
	}

	function enableAllButtons() {
		packageButtons.forEach(btn => {
			btn.disabled = false;
		});
	}

	function hideStatus() {
		statusDiv.classList.add('hidden');
	}

	packageButtons.forEach(button => {
		button.addEventListener('click', async (e: Event) => {
			e.preventDefault();

			const target = e.target as HTMLButtonElement;
			const packageKey = target.getAttribute('data-package');

			if (!packageKey) {
				showStatus('Ошибка: пакет не указан', 'error');
				return;
			}

			disableAllButtons();
			showStatus('Создание платежа...', 'loading');

			try {
				const response = await fetch('/api/payments/yookassa/create', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({ packageKey })
				});

				if (!response.ok) {
					const errorData = await response.json();
					showStatus(`Ошибка: ${errorData.error || 'Не удалось создать платеж'}`, 'error');
					enableAllButtons();
					return;
				}

				const data = await response.json();

				if (data.success && data.paymentUrl) {
					showStatus('Перенаправление на Yookassa...', 'loading');
					// Небольшая задержка перед редиректом для плавного UX
					setTimeout(() => {
						window.location.href = data.paymentUrl;
					}, 500);
				} else {
					showStatus(data.error || 'Ошибка при создании платежа', 'error');
					enableAllButtons();
				}
			} catch (error) {
				const errorMessage = error instanceof Error ? error.message : 'Неизвестная ошибка';
				showStatus(`Ошибка: ${errorMessage}`, 'error');
				enableAllButtons();
			}
		});
	});

	// Функция для обновления баланса в DOM
	function updateBalanceDisplay(newBalance: number) {
		const balanceElements = document.querySelectorAll('[data-balance-display]') as NodeListOf<HTMLElement>;
		balanceElements.forEach(el => {
			el.textContent = newBalance.toString();
		});
	}

	// Функция для получения текущего баланса
	async function fetchCurrentBalance(): Promise<number | null> {
		try {
			const response = await fetch('/api/user/balance');
			const data = await response.json();
			if (data.success && typeof data.generation_balance === 'number') {
				console.log(`[POLLING] Current balance: ${data.generation_balance}`);
				return data.generation_balance;
			}
		} catch (error) {
			console.error('[POLLING] Error fetching balance:', error);
		}
		return null;
	}

	// Проверка статуса платежа после возврата со страницы Yookassa
	async function checkPaymentStatus() {
		const params = new URLSearchParams(window.location.search);
		const paymentId = params.get('paymentId');

		// Сначала проверяем, есть ли pending платеж
		// Если нет - не показываем статус и не запускаем polling
		try {
			const checkUrl = paymentId
				? `/api/payments/yookassa/check?paymentId=${paymentId}`
				: `/api/payments/yookassa/check`;

			const initialCheck = await fetch(checkUrl);
			const initialData = await initialCheck.json();

			// Если нет pending платежа - выходим молча
			if (!initialData.success && initialData.error?.includes('No pending payment')) {
				console.log('[POLLING] No pending payment found, not showing status');
				hideStatus();
				return;
			}
		} catch (e) {
			// Ошибка при проверке - не показываем статус
			console.log('[POLLING] Could not check for pending payment');
			hideStatus();
			return;
		}

		// Платеж найден - показываем статус и запускаем polling
		console.log(`[POLLING] Starting payment status check (paymentId: ${paymentId || 'auto-detect'})`);
		showStatus('Проверка статуса платежа...', 'loading');

		try {
			let attempts = 0;
			const maxAttempts = 60; // Проверяем 60 раз с интервалом 1 сек = 60 сек всего

			const checkInterval = setInterval(async () => {
				attempts++;
				console.log(`[POLLING] Attempt ${attempts}/${maxAttempts}: Checking payment status...`);

				try {
					// Формируем URL с paymentId если он есть, иначе check endpoint найдет последний pending платеж
					const checkUrl = paymentId
						? `/api/payments/yookassa/check?paymentId=${paymentId}`
						: `/api/payments/yookassa/check`;

					const response = await fetch(checkUrl);
					const data = await response.json();

					console.log(`[POLLING] Check response: status=${data.status}, success=${data.success}`);

					if (data.status === 'succeeded') {
						clearInterval(checkInterval);
						console.log(`[POLLING] ✅ Payment succeeded! Fetching updated balance...`);

						// Получаем обновленный баланс
						const newBalance = await fetchCurrentBalance();
						if (newBalance !== null) {
							updateBalanceDisplay(newBalance);
							showStatus(`✓ Платеж успешно выполнен! Кредиты добавлены. Баланс: ${newBalance}`, 'success');
						} else {
							showStatus('✓ Платеж успешно выполнен! Обновляем баланс...', 'success');
							// Reload если не смогли получить баланс
							setTimeout(() => {
								window.location.href = '/billing';
							}, 2000);
						}

						// Очищаем параметр из URL и скрываем статус через 3 сек
						setTimeout(() => {
							window.history.replaceState({}, document.title, '/billing');
							hideStatus();
						}, 3000);

						enableAllButtons();
					} else if (data.status === 'failed' || data.status === 'cancelled') {
						clearInterval(checkInterval);
						console.error(`[POLLING] ❌ Payment ${data.status}`);
						showStatus(`Платеж ${data.status === 'cancelled' ? 'отменён' : 'не выполнен'}.`, 'error');
						// Скрываем статус через 4 сек при ошибке
						setTimeout(() => {
							hideStatus();
						}, 4000);
						enableAllButtons();
					} else if (attempts >= maxAttempts) {
						clearInterval(checkInterval);
						console.warn(`[POLLING] Max attempts reached (${maxAttempts})`);
						showStatus('Время проверки истекло. Платеж может всё ещё обрабатываться. Попробуйте обновить страницу.', 'error');
						// Скрываем статус через 4 сек при timeout
						setTimeout(() => {
							hideStatus();
						}, 4000);
						enableAllButtons();
					}
				} catch (fetchError) {
					console.error(`[POLLING] Error on attempt ${attempts}:`, fetchError);
				}
			}, 1000);
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : 'Неизвестная ошибка';
			console.error('[POLLING] Fatal error:', errorMessage);
			showStatus(`Ошибка при проверке статуса: ${errorMessage}`, 'error');
			// Скрываем статус через 4 сек при ошибке
			setTimeout(() => {
				hideStatus();
			}, 4000);
			enableAllButtons();
		}
	}

	// Проверяем статус платежа при загрузке страницы
	checkPaymentStatus();
</script>
