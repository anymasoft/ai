<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Depeche - AI Article Editor</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body, html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", sans-serif;
            background: #ffffff;
        }

        .app-container {
            display: flex;
            height: 100vh;
            width: 100%;
        }

        /* === SIDEBAR === */
        .sidebar {
            width: 280px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            padding: 24px 0;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 0 20px 24px;
            border-bottom: 1px solid #e8e8e8;
            margin-bottom: 20px;
        }

        .sidebar-title {
            font-size: 20px;
            font-weight: 700;
            color: #1a1a1a;
            margin: 0 0 16px 0;
            letter-spacing: -0.5px;
        }

        .btn-new-article {
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-weight: 600;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .btn-new-article:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .articles-list {
            flex: 1;
            overflow-y: auto;
            padding: 0 12px;
        }

        .article-item {
            padding: 12px 40px 12px 16px;
            margin-bottom: 8px;
            background: white;
            border: 1px solid #e8e8e8;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #1a1a1a;
            font-size: 14px;
            line-height: 1.4;
            display: block;
            text-align: left;
            text-decoration: none;
            position: relative;
        }

        .article-item:hover {
            background: #f5f5f5;
            border-color: #d0d0d0;
            transform: translateX(2px);
        }

        .article-item.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-color: #667eea;
            font-weight: 600;
            color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .article-delete-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px 6px;
            font-size: 18px;
            line-height: 1;
            transition: all 0.2s ease;
            opacity: 0;
            display: inline-block;
        }

        .article-item:hover .article-delete-btn {
            opacity: 1;
        }

        .article-delete-btn:hover {
            color: #e74c3c;
            transform: translateY(-50%) scale(1.2);
        }

        .sidebar-footer {
            padding: 16px 20px;
            border-top: 1px solid #e8e8e8;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 16px;
            flex-shrink: 0;
            cursor: pointer;
            transition: transform 0.2s ease;
            border: none;
            padding: 0;
        }

        .user-avatar:hover {
            transform: scale(1.1);
        }

        .user-info {
            flex: 1;
            min-width: 0;
        }

        .user-name {
            font-size: 13px;
            font-weight: 600;
            color: #1a1a1a;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .user-status {
            font-size: 12px;
            color: #888;
            margin: 2px 0 0 0;
        }

        /* === MAIN CONTENT === */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ffffff;
        }

        .editor-header {
            padding: 20px 32px;
            border-bottom: 1px solid #e8e8e8;
            background: #fafafa;
        }

        .article-title {
            font-size: 24px;
            font-weight: 700;
            color: #1a1a1a;
            margin: 0;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .dirty-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            transition: background-color 0.2s ease;
        }

        .dirty-indicator.clean {
            background-color: #22c55e;
        }

        .dirty-indicator.dirty {
            background-color: #3b82f6;
        }

        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 32px;
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-content {
            flex: 1;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 24px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            color: #2d2d2d;
            outline: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
            resize: none;
            word-wrap: break-word;
            white-space: pre-wrap;
        }

        .btn-save {
            position: absolute;
            top: 12px;
            right: 92px;
            width: 32px;
            height: 32px;
            padding: 8px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: #999;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .btn-save:hover:not(:disabled) {
            background: rgba(0, 0, 0, 0.05);
            color: #667eea;
        }

        .btn-save:active:not(:disabled) {
            background: rgba(102, 126, 234, 0.1);
        }

        .btn-save:disabled {
            cursor: not-allowed;
            color: #ddd;
            opacity: 0.5;
        }

        .btn-copy {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 32px;
            height: 32px;
            padding: 8px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: #999;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .btn-copy:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #667eea;
        }

        .btn-copy:active {
            background: rgba(102, 126, 234, 0.1);
        }

        .editor-content:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .editor-content::-webkit-scrollbar {
            width: 8px;
        }

        .editor-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .editor-content::-webkit-scrollbar-thumb {
            background: #d0d0d0;
            border-radius: 4px;
        }

        .editor-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* === PROMPT BAR === */
        .prompt-bar-container {
            padding: 20px 32px;
            background: white;
            border-top: 1px solid #e8e8e8;
        }

        .prompt-bar {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .prompt-input-wrapper {
            flex: 1;
            display: flex;
            align-items: flex-start;
            background: white;
            border: 1px solid #d0d0d0;
            border-radius: 12px;
            padding: 8px 16px;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .prompt-input-wrapper:focus-within {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1), 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .prompt-textarea {
            flex: 1;
            border: none;
            outline: none;
            padding: 8px 0;
            font-size: 14px;
            background: transparent;
            color: #1a1a1a;
            font-family: inherit;
            resize: none;
            overflow-y: auto;
            max-height: 120px;
            line-height: 1.5;
            width: 100%;
        }

        .prompt-textarea::placeholder {
            color: #999;
        }

        /* Стилизация скроллбара как в Anthropic/ChatGPT */
        .prompt-textarea::-webkit-scrollbar {
            width: 4px;
        }

        .prompt-textarea::-webkit-scrollbar-track {
            background: transparent;
        }

        .prompt-textarea::-webkit-scrollbar-thumb {
            background: #d0d0d0;
            border-radius: 2px;
        }

        .prompt-textarea::-webkit-scrollbar-thumb:hover {
            background: #b0b0b0;
        }

        .btn-apply {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            white-space: nowrap;
            height: fit-content;
            margin-top: 2px;
        }

        .btn-apply:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-apply:active {
            transform: translateY(0);
        }

        .btn-apply:disabled,
        .btn-apply.generating {
            cursor: not-allowed;
            position: relative;
            pointer-events: none;
        }

        .btn-apply:disabled::after,
        .btn-apply.generating::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            top: 50%;
            left: 50%;
            margin-left: -8px;
            margin-top: -8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spinner-rotate 0.8s linear infinite;
        }

        .btn-apply:disabled:hover,
        .btn-apply.generating:hover {
            cursor: not-allowed;
            transform: none;
        }

        @keyframes spinner-rotate {
            to {
                transform: rotate(360deg);
            }
        }

        /* === DROPDOWN === */
        .dropdown-menu {
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
            padding: 8px 0;
            min-width: 180px;
            background: white;
            backdrop-filter: blur(10px);
        }

        .dropdown-item {
            padding: 12px 18px;
            font-size: 14px;
            font-weight: 500;
            color: #1a1a1a;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .dropdown-item:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.08) 0%, rgba(118, 75, 162, 0.08) 100%);
            color: #667eea;
            padding-left: 22px;
        }

        .dropdown-divider {
            margin: 8px 0;
            border: none;
            border-top: 1px solid #f0f0f0;
        }

        /* === TOAST NOTIFICATION === */
        .notification-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            font-size: 13px;
            animation: slideIn 0.3s ease;
            z-index: 1050;
            max-width: 300px;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* === MODAL === */
        .modal-content {
            border: 1px solid #e8e8e8;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }

        .modal-header {
            border-bottom: 1px solid #e8e8e8;
            padding: 20px 24px;
        }

        .modal-body {
            padding: 24px;
        }

        .modal-footer {
            border-top: 1px solid #e8e8e8;
            padding: 16px 24px;
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .form-control {
            border: 1px solid #d0d0d0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .form-control:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn-secondary {
            background: #e8e8e8;
            border: none;
            color: #1a1a1a;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.3);
        }

        /* === SCROLLBAR === */
        .articles-list::-webkit-scrollbar {
            width: 6px;
        }

        .articles-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .articles-list::-webkit-scrollbar-thumb {
            background: #d0d0d0;
            border-radius: 3px;
        }

        .articles-list::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* === RESPONSIVE === */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
                padding: 16px 0;
                max-height: 120px;
            }

            .articles-list {
                max-height: 40px;
            }

            .sidebar-footer {
                display: none;
            }

            .editor-header,
            .editor-area,
            .prompt-bar-container {
                padding: 16px;
            }

            .article-title {
                font-size: 18px;
            }

            .editor-content {
                font-size: 14px;
            }

            .notification-toast {
                right: 10px;
                left: 10px;
                top: 10px;
                max-width: none;
            }
        }

        /* === SELECTION OVERLAY HIGHLIGHT === */
        .selection-overlay {
            position: absolute;
            background-color: rgba(100, 200, 255, 0.25);
            border-radius: 2px;
            pointer-events: none;
            z-index: 1;
        }

        /* === MARKDOWN PREVIEW === */
        .markdown-preview {
            flex: 1;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            padding: 24px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
            color: #2d2d2d;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            white-space: normal;
            word-wrap: break-word;
        }

        .markdown-preview h1 {
            font-size: 32px;
            font-weight: 700;
            margin: 24px 0 16px 0;
            color: #1a1a1a;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 12px;
        }

        .markdown-preview h2 {
            font-size: 24px;
            font-weight: 700;
            margin: 20px 0 12px 0;
            color: #1a1a1a;
        }

        .markdown-preview h3 {
            font-size: 20px;
            font-weight: 600;
            margin: 16px 0 10px 0;
            color: #2d2d2d;
        }

        .markdown-preview h4, .markdown-preview h5, .markdown-preview h6 {
            font-size: 16px;
            font-weight: 600;
            margin: 12px 0 8px 0;
            color: #2d2d2d;
        }

        .markdown-preview p {
            margin: 12px 0;
        }

        .markdown-preview ul, .markdown-preview ol {
            margin: 12px 0;
            padding-left: 32px;
        }

        .markdown-preview li {
            margin: 6px 0;
        }

        .markdown-preview code {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #d63384;
        }

        .markdown-preview pre {
            background: #f5f5f5;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
            margin: 12px 0;
            line-height: 1.5;
        }

        .markdown-preview pre code {
            background: transparent;
            border: none;
            padding: 0;
            color: #2d2d2d;
            font-size: 13px;
        }

        .markdown-preview blockquote {
            border-left: 4px solid #667eea;
            padding-left: 16px;
            margin-left: 0;
            margin-right: 0;
            color: #666;
            font-style: italic;
        }

        .markdown-preview strong {
            font-weight: 700;
            color: #1a1a1a;
        }

        .markdown-preview em {
            font-style: italic;
        }

        .markdown-preview a {
            color: #667eea;
            text-decoration: none;
            border-bottom: 1px solid #667eea;
        }

        .markdown-preview a:hover {
            color: #764ba2;
            border-bottom-color: #764ba2;
        }

        .markdown-preview table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
        }

        .markdown-preview th, .markdown-preview td {
            border: 1px solid #e0e0e0;
            padding: 10px 12px;
            text-align: left;
        }

        .markdown-preview th {
            background: #f9f9f9;
            font-weight: 600;
            color: #1a1a1a;
        }

        .markdown-preview hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 20px 0;
        }

        .btn-preview-toggle {
            position: absolute;
            top: 12px;
            right: 52px;
            width: 32px;
            height: 32px;
            padding: 8px;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: #999;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .btn-preview-toggle:hover {
            background: rgba(0, 0, 0, 0.05);
            color: #667eea;
        }

        .btn-preview-toggle:active {
            background: rgba(102, 126, 234, 0.1);
        }

        .btn-preview-toggle.active {
            color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }

        /* === UNSAVED CHANGES MODAL === */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideIn {
            from {
                transform: scale(0.95);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.2s ease;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 700;
            color: #1a1a1a;
            margin: 0 0 12px 0;
        }

        .modal-text {
            font-size: 14px;
            color: #666;
            margin: 0 0 24px 0;
            line-height: 1.5;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .modal-btn-cancel {
            background: #f3f4f6;
            color: #666;
        }

        .modal-btn-cancel:hover {
            background: #e5e7eb;
        }

        .modal-btn-discard {
            background: #f3f4f6;
            color: #666;
        }

        .modal-btn-discard:hover {
            background: #e5e7eb;
        }

        .modal-btn-save {
            background: #3b82f6;
            color: white;
        }

        .modal-btn-save:hover {
            background: #2563eb;
        }

        .modal-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="app-container">
        <!-- === SIDEBAR === -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1 class="sidebar-title">Depeche</h1>
                <button class="btn-new-article" onclick="openNewArticleModal()">+ New Article</button>
            </div>

            <div class="articles-list" id="articlesList">
            </div>

            <div class="sidebar-footer">
                <div class="dropdown">
                    <button class="user-avatar dropdown-toggle" type="button" id="userDropdown" data-bs-toggle="dropdown" aria-expanded="false">A</button>
                    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdown">
                        <li><a class="dropdown-item" href="#">Pricing</a></li>
                        <li><a class="dropdown-item" href="#">Settings</a></li>
                        <li><hr class="dropdown-divider"></li>
                        <li><a class="dropdown-item" href="#">Logout</a></li>
                    </ul>
                </div>
                <div class="user-info">
                    <p class="user-name">Alex Chen</p>
                    <p class="user-status">Pro</p>
                </div>
            </div>
        </div>

        <!-- === MAIN AREA === -->
        <div class="main-content">
            <div class="editor-header">
                <h2 class="article-title" id="currentTitle">
                    <span id="titleText"></span>
                    <div class="dirty-indicator clean" id="dirtyIndicator" title="Changes saved"></div>
                </h2>
            </div>

            <div class="editor-area">
                <div class="editor-wrapper">
                    <div class="editor-content" id="editorContent" contenteditable="true"></div>
                    <div class="markdown-preview" id="markdownPreview" style="display:none;"></div>
                    <button class="btn-preview-toggle" id="previewToggleButton" title="Toggle preview" type="button" aria-label="Toggle preview">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                            <circle cx="12" cy="12" r="3"></circle>
                        </svg>
                    </button>
                    <button class="btn-save" id="saveButton" title="Save article" type="button" aria-label="Save" disabled>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                            <polyline points="17 21 17 13 7 13 7 21"></polyline>
                            <polyline points="7 3 7 8 15 8"></polyline>
                        </svg>
                    </button>
                    <button class="btn-copy" id="copyButton" title="Copy to clipboard" type="button" aria-label="Copy">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                            <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="prompt-bar-container">
                <div class="prompt-bar">
                    <div class="prompt-input-wrapper">
                        <textarea
                            class="prompt-textarea"
                            id="promptInput"
                            placeholder="Describe what you would like to do... (e.g., &quot;Make it shorter&quot;, &quot;Add examples&quot;, &quot;Change tone&quot;)"
                            rows="1"
                        ></textarea>
                    </div>
                    <button class="btn-apply" onclick="applyPrompt()">Apply</button>
                </div>
            </div>
        </div>
    </div>

    <!-- === NEW ARTICLE MODAL === -->
    <div class="modal fade" id="newArticleModal" tabindex="-1" aria-labelledby="newArticleLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="newArticleLabel">Create New Article</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <input type="text" class="form-control" id="newArticleTitle" placeholder="Article title">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn-primary" onclick="createNewArticle()">Create</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // === API CONFIGURATION ===
        const API_BASE_URL = "http://localhost:8000/api";

        // === STATE ===
        let currentArticleId = null;
        let articles = {}; // Структура: { id, title, content (из БД), localContent (текущий текст), isDirty }

        // === PERSISTENT SELECTION STATE ===
        let savedSelection = null; // { startOffset, endOffset, text }
        let highlightJustApplied = false; // Флаг для предотвращения немедленного сброса

        // === GENERATION STATE ===
        let isGenerating = false; // Флаг для блокировки повторных вызовов Apply

        // === PREVIEW STATE ===
        let isPreviewMode = false; // Флаг для переключения между edit и preview режимом

        // === SAVE STATE ===
        let isDirty = false; // Флаг несохранённых изменений для текущей статьи
        let isSaving = false; // Флаг во время сохранения
        let pendingArticleId = null; // ID статьи для переключения после модального диалога


        // === INITIALIZATION ===
        document.addEventListener("DOMContentLoaded", function() {
            loadArticlesList();
            setupSelectionHandlers();
            setupCopyButton();
            setupPreviewToggle();
            setupDirtyTracking();
            setupSaveButton();
            updateIndicator();
        });

        // === SELECTION MANAGEMENT ===

        /**
         * Сохранить выделенный фрагмент при mouseup в editor
         */
        function setupSelectionHandlers() {
            const editorContent = document.getElementById("editorContent");

            // При mouseup с новым выделением - применяем подсветку
            editorContent.addEventListener("mouseup", function() {
                const selection = window.getSelection();
                if (selection.toString().trim()) {
                    // Есть выделение - сохраняем его и подсвечиваем
                    const range = selection.getRangeAt(0);
                    const preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(editorContent);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);

                    const startOffset = preCaretRange.toString().length - range.toString().length;
                    const endOffset = preCaretRange.toString().length;

                    savedSelection = {
                        startOffset: startOffset,
                        endOffset: endOffset,
                        text: range.toString()
                    };

                    console.log(`[SELECTION_SAVE] Выделено: "${savedSelection.text.substring(0, 50)}..."`);
                    console.log(`[SELECTION_SAVE] startOffset=${startOffset}, endOffset=${endOffset}`);

                    applySelectionHighlight();
                }
                // НЕ сбрасываем подсветку если нет выделения!
                // Подсветка остаётся видна до явного клика в пустое место
            });

            // При клике на пустое место в editor - сбрасываем выделение
            editorContent.addEventListener("click", function(e) {
                if (e.target === editorContent) {
                    // Клик на пустое место в editor
                    setTimeout(() => {
                        // НЕ сбрасываем если только что применили подсветку
                        if (highlightJustApplied) {
                            console.log("[SELECTION_CLICK] Игнорируем click т.к. только что применили подсветку");
                            return;
                        }

                        const selection = window.getSelection();
                        if (!selection.toString().trim() && savedSelection) {
                            console.log("[SELECTION_CLEAR] Выделение сброшено при клике на пустое место");
                            clearSelectionHighlight();
                            savedSelection = null;
                        }
                    }, 10);
                }
            });
        }

        /**
         * Инициализировать Copy-кнопку
         */
        function setupCopyButton() {
            const copyBtn = document.getElementById("copyButton");
            if (!copyBtn) {
                console.error("[COPY] Copy кнопка не найдена");
                return;
            }

            copyBtn.addEventListener("click", async function(e) {
                e.preventDefault();
                e.stopPropagation();

                const editorContent = document.getElementById("editorContent");
                const textToCopy = editorContent.textContent;

                if (!textToCopy.trim()) {
                    console.log("[COPY] Нечего копировать - текст пуст");
                    return;
                }

                try {
                    await navigator.clipboard.writeText(textToCopy);
                    console.log("[COPY] Текст скопирован в буфер обмена");

                    // Показываем визуальную обратную связь
                    const originalColor = copyBtn.style.color;
                    copyBtn.style.color = "#52c41a"; // Зелёный цвет

                    setTimeout(() => {
                        copyBtn.style.color = originalColor;
                    }, 1500);

                    showNotification("Текст скопирован в буфер обмена");
                } catch (err) {
                    console.error("[COPY] Ошибка при копировании:", err);
                    showNotification("Ошибка при копировании текста");
                }
            });

            console.log("[COPY] Copy кнопка инициализирована");
        }

        /**
         * Инициализировать кнопку toggle Preview
         */
        function setupPreviewToggle() {
            const previewToggleBtn = document.getElementById("previewToggleButton");
            if (!previewToggleBtn) {
                console.error("[PREVIEW] Preview toggle кнопка не найдена");
                return;
            }

            previewToggleBtn.addEventListener("click", function(e) {
                e.preventDefault();
                e.stopPropagation();
                togglePreview();
            });

            console.log("[PREVIEW] Preview toggle кнопка инициализирована");
        }

        /**
         * Переключиться между edit и preview режимом
         */
        function togglePreview() {
            isPreviewMode = !isPreviewMode;
            console.log(`[PREVIEW] Переключение на режим: ${isPreviewMode ? 'PREVIEW' : 'EDIT'}`);

            const editorContent = document.getElementById("editorContent");
            const markdownPreview = document.getElementById("markdownPreview");
            const previewToggleBtn = document.getElementById("previewToggleButton");

            if (isPreviewMode) {
                // Переход в Preview режим
                console.log("[PREVIEW] Включаю preview mode");

                // Скрыть editorContent, показать preview
                editorContent.style.display = "none";
                editorContent.setAttribute("contenteditable", "false");
                markdownPreview.style.display = "block";
                previewToggleBtn.classList.add("active");

                // Отключить selection handlers (они не нужны в preview)
                clearSelectionHighlight();
                savedSelection = null;

                // Отрендерить markdown
                renderPreview();
            } else {
                // Переход в Edit режим
                console.log("[PREVIEW] Включаю edit mode");

                // Показать editorContent, скрыть preview
                editorContent.style.display = "block";
                editorContent.setAttribute("contenteditable", "true");
                markdownPreview.style.display = "none";
                previewToggleBtn.classList.remove("active");

                // Вернуть фокус в editor
                editorContent.focus();
            }
        }

        /**
         * Отрендерить markdown в preview контейнер
         */
        function renderPreview() {
            const editorContent = document.getElementById("editorContent");
            const markdownPreview = document.getElementById("markdownPreview");
            const rawText = editorContent.textContent;

            if (!rawText.trim()) {
                markdownPreview.innerHTML = "<p style=\"color: #999;\">Текст пуст</p>";
                return;
            }

            try {
                // marked доступен из CDN
                const htmlContent = marked.parse(rawText);
                markdownPreview.innerHTML = htmlContent;
                console.log("[PREVIEW] Markdown успешно отрендерен");
            } catch (err) {
                console.error("[PREVIEW] Ошибка при рендере markdown:", err);
                markdownPreview.innerHTML = `<p style="color: red;">Ошибка: ${err.message}</p>`;
            }
        }

        /**
         * Инициализировать отслеживание изменений текста (onInput)
         */
        function setupDirtyTracking() {
            const editorContent = document.getElementById("editorContent");
            if (!editorContent) {
                console.error("[DIRTY] Editor не найден");
                return;
            }

            editorContent.addEventListener("input", function() {
                updateDirtyState();
            });

            console.log("[DIRTY] Отслеживание изменений инициализировано");
        }

        /**
         * Обновить состояние isDirty для текущей статьи
         */
        function updateDirtyState() {
            if (!currentArticleId) return;

            const editorContent = document.getElementById("editorContent");
            const article = articles[currentArticleId];

            if (!article) return;

            const currentText = editorContent.textContent;
            const wasClean = !isDirty;

            // Сравниваем с последней сохранённой версией
            isDirty = (currentText !== article.content);
            article.isDirty = isDirty;

            // Обновить UI только если состояние изменилось
            if (wasClean !== !isDirty) {
                updateSaveButtonState();
                updateIndicator();
            }

            console.log(`[DIRTY] isDirty=${isDirty} для статьи ${currentArticleId}`);
        }

        /**
         * Обновить визуальный индикатор isDirty
         */
        function updateIndicator() {
            const indicator = document.getElementById("dirtyIndicator");
            if (!indicator) return;

            if (isDirty) {
                indicator.classList.remove("clean");
                indicator.classList.add("dirty");
                indicator.title = "Unsaved changes";
            } else {
                indicator.classList.remove("dirty");
                indicator.classList.add("clean");
                indicator.title = "Changes saved";
            }

            console.log(`[INDICATOR] isDirty=${isDirty}`);
        }

        /**
         * Обновить состояние кнопки Save
         */
        function updateSaveButtonState() {
            const saveBtn = document.getElementById("saveButton");
            if (!saveBtn) return;

            if (isDirty && !isSaving) {
                saveBtn.disabled = false;
                console.log("[SAVE] Кнопка Save активирована");
            } else {
                saveBtn.disabled = true;
                console.log("[SAVE] Кнопка Save деактивирована");
            }
        }

        /**
         * Инициализировать кнопку Save
         */
        function setupSaveButton() {
            const saveBtn = document.getElementById("saveButton");
            if (!saveBtn) {
                console.error("[SAVE] Save кнопка не найдена");
                return;
            }

            saveBtn.addEventListener("click", async function(e) {
                e.preventDefault();
                e.stopPropagation();
                await saveArticle();
            });

            console.log("[SAVE] Save кнопка инициализирована");
        }

        /**
         * Сохранить текущую статью
         * @returns {Promise<boolean>} true если сохранение успешно, false если ошибка
         */
        async function saveArticle() {
            if (!currentArticleId || isSaving) {
                console.log("[SAVE] Попытка сохранения отклонена: нет статьи или уже сохраняется");
                return false;
            }

            const article = articles[currentArticleId];
            if (!article || !isDirty) {
                console.log("[SAVE] Нечего сохранять - статья чистая или не найдена");
                return false;
            }

            isSaving = true;
            const saveBtn = document.getElementById("saveButton");
            if (saveBtn) saveBtn.disabled = true;

            console.log(`[SAVE] Начинаю сохранение статьи ${currentArticleId}`);

            try {
                const editorContent = document.getElementById("editorContent");
                const textToSave = editorContent.textContent;

                const response = await fetch(`${API_BASE_URL}/articles/${currentArticleId}`, {
                    method: "PATCH",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ content: textToSave })
                });

                console.log(`[SAVE] Статус ответа: ${response.status}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || "Ошибка при сохранении");
                }

                const savedArticle = await response.json();
                console.log("[SAVE] Статья успешно сохранена");

                // Обновляем сохранённую версию
                article.content = textToSave;
                isDirty = false;
                article.isDirty = false;

                updateSaveButtonState();
                updateIndicator();
                showNotification("Статья сохранена!");
                return true;
            } catch (err) {
                console.error("[SAVE] Ошибка при сохранении:", err);
                showNotification("Ошибка при сохранении: " + err.message);
                return false;
            } finally {
                isSaving = false;
                updateSaveButtonState();
            }
        }

        /**
         * Очистить все визуальные overlayи подсветки
         * ТЕКСТ НЕ МЕНЯЕТСЯ - только удаляются визуальные элементы
         */
        function clearSelectionHighlight() {
            const editor = document.getElementById("editorContent");
            const overlays = editor.querySelectorAll(".selection-overlay");
            overlays.forEach(overlay => overlay.remove());
            console.log("[HIGHLIGHT] Все overlayи удалены");
        }

        /**
         * Применить визуальную подсветку к сохраненному выделению
         * АРХИТЕКТУРА: Range.getClientRects() → overlay divы
         * ТЕКСТ ВООБЩЕ НЕ МЕНЯЕТСЯ
         */
        function applySelectionHighlight() {
            clearSelectionHighlight(); // Очищаем старые overlayи

            if (!savedSelection) return;

            const editor = document.getElementById("editorContent");
            const selection = window.getSelection();

            // Проверяем что selection существует и находится в editorе
            if (!selection || selection.rangeCount === 0) {
                console.log("[HIGHLIGHT] Нет активного selection");
                return;
            }

            const range = selection.getRangeAt(0);

            // Проверяем что Range находится внутри editorа
            if (!editor.contains(range.commonAncestorContainer)) {
                console.log("[HIGHLIGHT] Range вне editor");
                return;
            }

            // Получаем все прямоугольники выделённого текста
            const rects = range.getClientRects();
            if (rects.length === 0) {
                console.log("[HIGHLIGHT] Range не имеет видимых rectов");
                return;
            }

            // Получаем позицию editorа для расчета relative координат
            const editorRect = editor.getBoundingClientRect();

            // Для каждого rect создаем overlay div
            for (let rect of rects) {
                const overlay = document.createElement("div");
                overlay.className = "selection-overlay";

                // Позиция относительно editorа
                const top = rect.top - editorRect.top + editor.scrollTop;
                const left = rect.left - editorRect.left + editor.scrollLeft;
                const width = rect.width;
                const height = rect.height;

                // Устанавливаем стили
                overlay.style.top = top + "px";
                overlay.style.left = left + "px";
                overlay.style.width = width + "px";
                overlay.style.height = height + "px";

                // Добавляем в editor
                editor.appendChild(overlay);
            }

            console.log("[HIGHLIGHT] Подсветка применена (" + rects.length + " rectов)");

            // Устанавливаем флаг
            highlightJustApplied = true;
            setTimeout(() => {
                highlightJustApplied = false;
            }, 100);
        }

        // === HELPER FUNCTIONS FOR MODE DETECTION ===

        /**
         * Определить режим редактирования по состоянию редактора
         *
         * РЕЖИМ 1: Текст пуст → ПЛАН (любой ввод = тема)
         * РЕЖИМ 2: Текст есть + нет выделения → ПРАВКА ВСЕГО
         * РЕЖИМ 3: Текст есть + есть выделение → ПРАВКА ФРАГМЕНТА
         */
        function detectMode() {
            const editorContent = document.getElementById("editorContent").textContent.trim();

            // РЕЖИМ 1: текст пуст
            if (!editorContent) {
                return {
                    mode: 1,
                    description: "ПЛАН: генерация плана статьи"
                };
            }

            // РЕЖИМ 3: текст есть И есть СОХРАНЕННОЕ выделение
            if (savedSelection && savedSelection.text && savedSelection.text.length > 0) {
                console.log(`[DETECT] Режим 3: найдено сохраненное выделение`);
                return {
                    mode: 3,
                    description: "ФРАГМЕНТ: редактирование выделенного текста",
                    selectedText: savedSelection.text
                };
            }

            // РЕЖИМ 2: текст есть, но нет выделения
            console.log(`[DETECT] Режим 2: весь текст`);
            return {
                mode: 2,
                description: "ВЕСЬ ТЕКСТ: редактирование всей статьи"
            };
        }

        /**
         * Получить выделенный фрагмент вместе с контекстом из СОХРАНЕННОГО выделения
         */
        function getSelectionWithContext() {
            if (!savedSelection || !savedSelection.text) {
                console.log("[SELECTION] Нет сохраненного выделения");
                return null;
            }

            const fullText = document.getElementById("editorContent").textContent;
            const { startOffset, endOffset } = savedSelection;

            console.log(`[SELECTION] Используем сохраненное выделение. startOffset=${startOffset}, endOffset=${endOffset}`);
            console.log(`[SELECTION] Размер фрагмента: ${endOffset - startOffset} символов`);

            // Берём предыдущий абзац (от последнего двойного переноса ДО выделения)
            let beforeStart = startOffset;
            let doubleNewlineCount = 0;
            for (let i = startOffset - 1; i >= 0; i--) {
                if (fullText[i] === "\n") {
                    doubleNewlineCount++;
                    if (doubleNewlineCount >= 2) {
                        beforeStart = i + 1;
                        break;
                    }
                } else if (fullText[i] !== " " && fullText[i] !== "\r") {
                    doubleNewlineCount = 0;
                }
            }
            if (beforeStart === startOffset) beforeStart = 0; // Если это начало документа

            const beforeContext = fullText.substring(beforeStart, startOffset).trim();
            console.log(`[SELECTION] До: ${beforeContext.substring(0, 50)}...`);

            // Берём следующий абзац (от конца выделения ДО следующего двойного переноса)
            let afterEnd = endOffset;
            doubleNewlineCount = 0;
            for (let i = endOffset; i < fullText.length; i++) {
                if (fullText[i] === "\n") {
                    doubleNewlineCount++;
                    if (doubleNewlineCount >= 2) {
                        afterEnd = i;
                        break;
                    }
                } else if (fullText[i] !== " " && fullText[i] !== "\r") {
                    doubleNewlineCount = 0;
                }
            }
            if (afterEnd === endOffset) afterEnd = fullText.length; // Если это конец документа

            const afterContext = fullText.substring(endOffset, afterEnd).trim();
            console.log(`[SELECTION] После: ${afterContext.substring(0, 50)}...`);

            return {
                before: beforeContext,
                fragment: savedSelection.text,
                after: afterContext
            };
        }

        // === API FUNCTIONS ===

        async function loadArticlesList() {
            try {
                console.log("[LOAD] Загружаем список статей");
                const response = await fetch(`${API_BASE_URL}/articles`);
                const articlesList = await response.json();
                console.log(`[LOAD] Получено ${articlesList.length} статей от API`);

                // Очищаем sidebar и DOM кэш
                const articlesList_elem = document.getElementById("articlesList");
                articlesList_elem.innerHTML = "";
                articles = {};
                currentArticleId = null;
                console.log("[LOAD] Очищен кэш и sidebar");

                if (articlesList.length === 0) {
                    console.log("[LOAD] Список статей пуст");
                    const titleElem = document.getElementById("titleText");
                    if (titleElem) titleElem.textContent = "";
                    document.getElementById("editorContent").textContent = "";
                    return;
                }

                // Заполняем sidebar
                articlesList.forEach((article, index) => {
                    console.log(`[LOAD] Добавляем статью: ID=${article.id}, title="${article.title}"`);
                    // Сохраняем статью с полными метаданными для отслеживания сохранения
                    article.isDirty = false; // На загрузке статья чистая
                    articles[article.id] = article;
                    // Первую статью отмечаем как активную
                    const isFirst = index === 0;
                    addArticleToSidebar(article.id, article.title, isFirst);
                });

                // Загружаем первую статью
                if (articlesList.length > 0) {
                    const firstId = articlesList[0].id;
                    console.log(`[LOAD] Устанавливаем первую статью. ID=${firstId}`);
                    currentArticleId = firstId;
                    const firstArticle = articles[firstId];
                    console.log(`[LOAD] currentArticleId установлен на: ${currentArticleId}`);
                    const titleText = document.getElementById("titleText");
                    if (titleText) titleText.textContent = firstArticle.title;
                    // ВАЖНО: НЕ загружаем content из articles - только заголовок!
                    document.getElementById("editorContent").textContent = "";
                    document.getElementById("promptInput").value = "";
                    console.log("[LOAD] UI обновлен");
                }
            } catch (error) {
                console.error("[LOAD] Критическая ошибка:", error);
                showNotification("Ошибка при загрузке списка статей");
            }
        }

        async function loadArticleContent(articleId) {
            try {
                const response = await fetch(`${API_BASE_URL}/articles/${articleId}`);
                if (!response.ok) throw new Error("Статья не найдена");

                const article = await response.json();
                return article;
            } catch (error) {
                console.error("Ошибка при загрузке статьи:", error);
                showNotification("Ошибка при загрузке статьи");
                return null;
            }
        }

        async function createEmptyArticleViaAPI(title) {
            // Создаёт пустую статью БЕЗ генерации плана
            try {
                console.log(`[CREATE_API] Создаём пустую статью. title="${title}"`);

                const url = `${API_BASE_URL}/articles`;
                const body = { topic: title };
                console.log(`[CREATE_API] URL: ${url}`);
                console.log(`[CREATE_API] Тело: ${JSON.stringify(body)}`);

                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(body)
                });

                console.log(`[CREATE_API] Статус ответа: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const error = await response.json();
                    console.error(`[CREATE_API] Ошибка от сервера: ${error.detail}`);
                    throw new Error(error.detail || "Ошибка при создании статьи");
                }

                const article = await response.json();
                console.log(`[CREATE_API] Статья успешно создана! ID=${article.id}, title="${article.title}"`);

                // Инициализируем флаг isDirty для новой статьи
                article.isDirty = false;
                return article;
            } catch (error) {
                console.error("[CREATE_API] Критическая ошибка:", error);
                showNotification("Ошибка: " + error.message);
                return null;
            }
        }

        async function generatePlanForArticleViaAPI(articleId, topic, format = "plain") {
            // Генерирует план статьи и обновляет её
            try {
                console.log(`[PLAN_GEN] Начинаем генерацию плана. articleId=${articleId}, topic="${topic}", format="${format}"`);
                showNotification("Генерирую план статьи...");

                const url = `${API_BASE_URL}/articles/${articleId}/plan`;
                const requestBody = {
                    topic: topic,
                    format: format
                };

                console.log(`[PLAN_GEN] URL запроса: ${url}`);
                console.log(`[PLAN_GEN] Тело запроса: ${JSON.stringify(requestBody)}`);

                const response = await fetch(url, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log(`[PLAN_GEN] Статус ответа: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    const error = await response.json();
                    console.error(`[PLAN_GEN] Ошибка от сервера: ${error.detail}`);
                    throw new Error(error.detail || "Ошибка при генерации плана");
                }

                const article = await response.json();
                console.log(`[PLAN_GEN] Успешно получен план: ${article.id} - ${article.title}`);
                const contentPreview = (article.content || "").substring(0, 100);
                console.log(`[PLAN_GEN] Контент: ${contentPreview}...`);
                return article;
            } catch (error) {
                console.error("[PLAN_GEN] Критическая ошибка:", error);
                showNotification("Ошибка при генерации: " + error.message);
                return null;
            }
        }

        async function deleteArticleViaAPI(articleId) {
            try {
                const response = await fetch(`${API_BASE_URL}/articles/${articleId}`, {
                    method: "DELETE"
                });

                if (!response.ok) throw new Error("Ошибка при удалении");

                delete articles[articleId];
                return true;
            } catch (error) {
                console.error("Ошибка при удалении статьи:", error);
                showNotification("Ошибка при удалении статьи");
                return false;
            }
        }

        /**
         * РЕЖИМ 2: Редактирование ВСЕГО текста статьи
         */
        async function editFullTextViaAPI(articleId, currentText, instruction, format = "plain") {
            try {
                console.log(`[EDIT_FULL_API] Начинаем редактирование всего текста. articleId=${articleId}, format="${format}"`);
                console.log(`[EDIT_FULL_API] Текст из поля: ${currentText.length} символов`);
                console.log(`[EDIT_FULL_API] Инструкция: "${instruction}"`);

                const url = `${API_BASE_URL}/articles/${articleId}/edit-full`;
                const body = {
                    current_text: currentText,
                    instruction: instruction,
                    format: format
                };

                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                console.log(`[EDIT_FULL_API] Статус ответа: ${response.status}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || "Ошибка при редактировании");
                }

                const article = await response.json();
                console.log(`[EDIT_FULL_API] Текст успешно отредактирован`);
                return article;
            } catch (error) {
                console.error("[EDIT_FULL_API] Критическая ошибка:", error);
                showNotification("Ошибка при редактировании: " + error.message);
                return null;
            }
        }

        /**
         * РЕЖИМ 3: Редактирование ВЫДЕЛЕННОГО ФРАГМЕНТА
         */
        async function editFragmentViaAPI(articleId, beforeContext, fragment, afterContext, instruction, format = "plain") {
            try {
                console.log(`[EDIT_FRAGMENT_API] Начинаем редактирование фрагмента. articleId=${articleId}, format="${format}"`);
                console.log(`[EDIT_FRAGMENT_API] Инструкция: "${instruction}"`);
                console.log(`[EDIT_FRAGMENT_API] Размер фрагмента: ${fragment.length} символов`);

                const url = `${API_BASE_URL}/articles/${articleId}/edit-fragment`;
                const body = {
                    before_context: beforeContext,
                    fragment: fragment,
                    after_context: afterContext,
                    instruction: instruction,
                    format: format
                };

                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });

                console.log(`[EDIT_FRAGMENT_API] Статус ответа: ${response.status}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || "Ошибка при редактировании фрагмента");
                }

                const article = await response.json();
                console.log(`[EDIT_FRAGMENT_API] Фрагмент успешно отредактирован`);
                return article;
            } catch (error) {
                console.error("[EDIT_FRAGMENT_API] Критическая ошибка:", error);
                showNotification("Ошибка при редактировании: " + error.message);
                return null;
            }
        }

        // === TYPEWRITER EFFECT ===
        /**
         * РЕЖИМ 1: Классический typewriter effect (текст был пуст)
         */
        async function typewriterEffect(element, text, speed = 20) {
            console.log("[TYPEWRITER] Классический эффект печати");
            element.textContent = "";
            for (let i = 0; i < text.length; i++) {
                element.textContent += text[i];
                await new Promise(resolve => setTimeout(resolve, speed));
            }
            // Обновить preview если он включен
            if (isPreviewMode) {
                renderPreview();
            }
        }

        /**
         * РЕЖИМ 2: Посимвольная замена ВСЕГО текста
         */
        async function animateTextReplacement(element, oldText, newText, speed = 10) {
            console.log("[REPLACE_TEXT] Анимирую замену всего текста");
            console.log(`[REPLACE_TEXT] Старый текст: ${oldText.length} символов`);
            console.log(`[REPLACE_TEXT] Новый текст: ${newText.length} символов`);

            // ФАЗА 1: Заменяем посимвольно до длины меньшего текста
            const minLen = Math.min(oldText.length, newText.length);

            for (let i = 0; i < minLen; i++) {
                if (oldText[i] !== newText[i]) {
                    let currentText = element.textContent;
                    currentText = currentText.substring(0, i) + newText[i] + currentText.substring(i + 1);
                    element.textContent = currentText;
                }
                await new Promise(resolve => setTimeout(resolve, speed));
            }

            // ФАЗА 2: Если новый текст длиннее - добавляем символы в конец
            if (newText.length > oldText.length) {
                for (let i = oldText.length; i < newText.length; i++) {
                    element.textContent += newText[i];
                    await new Promise(resolve => setTimeout(resolve, speed));
                }
            }
            // ФАЗА 3: Если старый текст длиннее - удаляем лишние символы
            else if (oldText.length > newText.length) {
                element.textContent = newText;
            }

            console.log("[REPLACE_TEXT] Замена завершена");

            // Обновить preview если он включен
            if (isPreviewMode) {
                renderPreview();
            }
        }

        /**
         * РЕЖИМ 3: Посимвольная замена ВЫДЕЛЕННОГО ФРАГМЕНТА
         * АРХИТЕКТУРА: [before][печать нового][остаток старого][after]
         * Работает для любой длины newFragment (короче, равна, длиннее oldFragment)
         *
         * ФАЗЫ АНИМАЦИИ:
         * 1. Если newLen < oldLen: печать нового + удаление хвоста старого посимвольно
         * 2. Если newLen >= oldLen: печать нового (как обычно)
         */
        async function animateFragmentReplacement(element, fullOldText, startOffset, endOffset, newFragment, speed = 10) {
            console.log(`[REPLACE_FRAGMENT] Анимирую замену фрагмента. Позиция: ${startOffset}-${endOffset}`);

            // Вычисляем неизменяемые части ДО начала цикла
            const before = fullOldText.substring(0, startOffset);
            const after = fullOldText.substring(endOffset);
            const oldFragment = fullOldText.substring(startOffset, endOffset);

            const oldLen = oldFragment.length;
            const newLen = newFragment.length;

            console.log(`[REPLACE_FRAGMENT] Старый: ${oldLen} символов, Новый: ${newLen} символов`);

            // ========== ФАЗА 1: Печать нового фрагмента ==========
            for (let i = 0; i < newLen; i++) {
                // Печатаем часть нового фрагмента (от 0 до i+1)
                const printedPart = newFragment.substring(0, i + 1);

                // Оставляем остаток старого фрагмента (после i+1)
                const remainingOld = oldFragment.substring(i + 1);

                // Собираем финальный текст
                element.textContent = before + printedPart + remainingOld + after;

                await new Promise(resolve => setTimeout(resolve, speed));
            }

            // ========== ФАЗА 2: Удаление хвоста (ТОЛЬКО если новый текст короче) ==========
            if (newLen < oldLen) {
                const tailLen = oldLen - newLen;
                console.log(`[REPLACE_FRAGMENT] Удаляю хвост: ${tailLen} символов`);

                for (let j = 0; j < tailLen; j++) {
                    // На каждой итерации удаляем j-й символ хвоста
                    // Остаток хвоста начинается с позиции (newLen + j + 1)
                    const remainingTail = oldFragment.substring(newLen + j + 1);
                    element.textContent = before + newFragment + remainingTail + after;

                    await new Promise(resolve => setTimeout(resolve, speed));
                }
            }

            console.log("[REPLACE_FRAGMENT] Замена фрагмента завершена успешно");

            // Обновить preview если он включен
            if (isPreviewMode) {
                renderPreview();
            }
        }

        // === UI FUNCTIONS ===

        function addArticleToSidebar(articleId, title, select = true) {
            const list = document.getElementById("articlesList");
            const button = document.createElement("button");
            button.className = "article-item";
            if (select) button.classList.add("active");
            button.setAttribute("data-id", articleId);
            button.innerHTML = title + `<span class="article-delete-btn" onclick="deleteArticle(event, ${articleId})" title="Delete">×</span>`;
            button.onclick = function(e) {
                if (e.target.classList.contains("article-delete-btn")) return;
                selectArticle(this, articleId);
            };
            list.appendChild(button);
        }

        /**
         * Показать modal с предупреждением о несохранённых изменениях
         */
        function showUnsavedChangesModal(targetId) {
            pendingArticleId = targetId;
            const modal = document.getElementById("unsavedChangesModal");
            if (modal) {
                modal.classList.add("visible");
                console.log(`[MODAL] Показываю modal для переключения на статью ${targetId}`);
            }
        }

        /**
         * Скрыть modal
         */
        function hideUnsavedChangesModal() {
            const modal = document.getElementById("unsavedChangesModal");
            if (modal) {
                modal.classList.remove("visible");
                console.log("[MODAL] Modal закрыта");
            }
        }

        /**
         * Обработчик кнопки Save в modal
         */
        async function onModalSave() {
            console.log("[MODAL] Пользователь выбрал Save");

            if (!currentArticleId) {
                hideUnsavedChangesModal();
                return;
            }

            // Сохраняем текущую статью
            const saveSuccess = await saveArticle();
            if (saveSuccess) {
                // После успешного сохранения переключаемся
                if (pendingArticleId && pendingArticleId !== currentArticleId) {
                    const targetElement = document.querySelector(`.article-item[data-id="${pendingArticleId}"]`);
                    if (targetElement) {
                        performArticleSwitch(targetElement, pendingArticleId);
                    }
                }
                pendingArticleId = null;
                hideUnsavedChangesModal();
            }
        }

        /**
         * Обработчик кнопки Discard в modal
         */
        function onModalDiscard() {
            console.log("[MODAL] Пользователь выбрал Discard");

            // Восстанавливаем последнюю сохранённую версию
            if (currentArticleId && articles[currentArticleId]) {
                const article = articles[currentArticleId];
                const editorContent = document.getElementById("editorContent");
                editorContent.textContent = article.content || "";

                // Сбрасываем isDirty
                isDirty = false;
                article.isDirty = false;
                updateSaveButtonState();
                updateIndicator();
            }

            // Переключаемся на целевую статью
            if (pendingArticleId && pendingArticleId !== currentArticleId) {
                const targetElement = document.querySelector(`.article-item[data-id="${pendingArticleId}"]`);
                if (targetElement) {
                    performArticleSwitch(targetElement, pendingArticleId);
                }
            }

            pendingArticleId = null;
            hideUnsavedChangesModal();
        }

        /**
         * Обработчик кнопки Cancel в modal
         */
        function onModalCancel() {
            console.log("[MODAL] Пользователь выбрал Cancel");
            pendingArticleId = null;
            hideUnsavedChangesModal();
        }

        function selectArticle(element, id) {
            console.log(`[SELECT] Попытка переключения на статью ID=${id}`);

            // Если это та же статья - ничего не делаем
            if (currentArticleId === id) {
                console.log("[SELECT] Это же текущая статья, игнорирую");
                return;
            }

            // Проверяем есть ли несохранённые изменения в текущей статье
            if (currentArticleId && isDirty) {
                console.log(`[SELECT] Обнаружены несохранённые изменения в статье ${currentArticleId}`);
                console.log(`[SELECT] Показываю modal для переключения на статью ${id}`);
                showUnsavedChangesModal(id);
                return;
            }

            // Нет несохранённых изменений - просто переключаемся
            performArticleSwitch(element, id);
        }

        /**
         * Выполнить переключение на другую статью (без проверки isDirty)
         */
        function performArticleSwitch(element, id) {
            console.log(`[SELECT] Выполняю переключение на статью ID=${id}`);

            // Переключить активный класс в sidebar
            document.querySelectorAll(".article-item").forEach(item => {
                item.classList.remove("active");
            });
            element.classList.add("active");

            currentArticleId = id;
            console.log(`[SELECT] currentArticleId установлен на: ${currentArticleId}`);

            // Загрузить статью
            const article = articles[id];
            console.log(`[SELECT] Статья из кэша: ${article ? "найдена" : "НЕ найдена"}`);

            if (article) {
                console.log(`[SELECT] Отображаем: title="${article.title}"`);
                const titleText = document.getElementById("titleText");
                if (titleText) {
                    titleText.textContent = article.title;
                }

                // Загружаем content (сохранённую версию) в editorContent
                const editorContent = document.getElementById("editorContent");
                editorContent.textContent = article.content || "";

                console.log(`[SELECT] Текст загружен: ${(article.content || "").length} символов`);

                // Сбрасываем isDirty для этой статьи
                isDirty = false;
                article.isDirty = false;
                updateSaveButtonState();
                updateIndicator();

                // Очищаем promptInput
                document.getElementById("promptInput").value = "";
                document.getElementById("promptInput").style.height = "auto";

                // Если был preview - выходим из него
                if (isPreviewMode) {
                    togglePreview();
                }

                console.log("[SELECT] Переключение завершено");
            } else {
                console.log(`[SELECT] ОШИБКА: Статья не найдена в кэше!`);
            }
        }

        // Delete article
        async function deleteArticle(event, id) {
            event.stopPropagation();
            const success = await deleteArticleViaAPI(id);

            if (success) {
                const articleButton = document.querySelector(`.article-item[data-id="${id}"]`);
                articleButton.remove();

                // Если это была активная статья - переключиться на другую
                const activeItem = document.querySelector(".article-item.active");
                if (!activeItem) {
                    const firstArticle = document.querySelector(".article-item");
                    if (firstArticle) {
                        const firstId = parseInt(firstArticle.getAttribute("data-id"));
                        selectArticle(firstArticle, firstId);
                    } else {
                        const titleElem = document.getElementById("titleText");
                        if (titleElem) titleElem.textContent = "No articles";
                        document.getElementById("editorContent").textContent = "";
                        document.getElementById("promptInput").value = "";
                    }
                }

                showNotification("Article deleted");
            }
        }

        // Open new article modal
        function openNewArticleModal() {
            const modal = new bootstrap.Modal(document.getElementById("newArticleModal"));
            document.getElementById("newArticleTitle").value = "";
            document.getElementById("newArticleTitle").focus();
            modal.show();
        }

        // Create new article (through API) - пустая статья БЕЗ генерации
        async function createNewArticle() {
            console.log("[CREATE] Нажата кнопка создания статьи");
            const title = document.getElementById("newArticleTitle").value.trim();
            console.log(`[CREATE] Введённое название: "${title}"`);

            if (!title) {
                console.log("[CREATE] Ошибка: название пусто");
                showNotification("Please enter an article title");
                return;
            }

            const modal = bootstrap.Modal.getInstance(document.getElementById("newArticleModal"));
            modal.hide();

            // Вызваем API для создания ПУСТОЙ статьи (БЕЗ генерации плана)
            console.log("[CREATE] Вызываем createEmptyArticleViaAPI");
            const article = await createEmptyArticleViaAPI(title);
            if (!article) {
                console.log("[CREATE] Ошибка: API не вернул статью");
                return;
            }

            console.log(`[CREATE] Статья создана! ID=${article.id}, title="${article.title}"`);

            // Добавляем в кэш и в sidebar
            // ВАЖНО: НЕ сохраняем content в articles - только metadata!
            delete article.content;
            articles[article.id] = article;
            console.log(`[CREATE] Добавлена в кэш`);

            addArticleToSidebar(article.id, article.title, true);
            console.log(`[CREATE] Добавлена в sidebar`);

            currentArticleId = article.id;
            console.log(`[CREATE] currentArticleId установлен на: ${currentArticleId}`);

            // Отображаем в редактор - пусто, БЕЗ typewriter effect
            const titleElem = document.getElementById("titleText");
            if (titleElem) titleElem.textContent = article.title;
            document.getElementById("editorContent").textContent = "";

            document.getElementById("promptInput").value = "";
            document.getElementById("promptInput").style.height = "auto";

            console.log("[CREATE] UI обновлен. Готово к вводу промпта");
            showNotification("Статья создана. Введите план в prompt bar.");
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement("div");
            notification.className = "notification-toast";
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = "slideIn 0.3s ease reverse";
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 3000);
        }

        // Заблокировать кнопку Apply
        function lockApplyButton() {
            console.log("[UI] Блокирую кнопку Apply");
            isGenerating = true;
            const btn = document.querySelector(".btn-apply");
            if (btn) {
                btn.disabled = true;
                btn.classList.add("generating");
                console.log("[UI] Кнопка заблокирована со спиннером");
            } else {
                console.error("[UI] ОШИБКА: кнопка .btn-apply не найдена!");
            }
        }

        // Разблокировать кнопку Apply
        function unlockApplyButton() {
            console.log("[UI] Разблокирую кнопку Apply");
            isGenerating = false;
            const btn = document.querySelector(".btn-apply");
            if (btn) {
                btn.disabled = false;
                btn.classList.remove("generating");
                console.log("[UI] Кнопка разблокирована");
            } else {
                console.error("[UI] ОШИБКА: кнопка .btn-apply не найдена!");
            }
        }

        /**
         * Анализировать промпт пользователя и определить, просит ли он Markdown-форматирования
         * @param {string} prompt - Текст промпта пользователя
         * @returns {boolean} - true если просит Markdown, false если plain text
         */
        function detectMarkdownRequest(prompt) {
            if (!prompt) return false;

            const lowerPrompt = prompt.toLowerCase();

            // Триггеры для Markdown-форматирования
            const markdownTriggers = [
                "markdown",
                "оформи",
                "оформь",
                "оформить",
                "с заголовками",
                "с подзаголовками",
                "в виде списка",
                "как список",
                "как код",
                "код-блок",
                "кодблок",
                "структурированно",
                "структурировано",
                "структуру",
                "структуру",
                "форматирование",
                "##",
                "```",
                "-",
                "список",
                "нумерованный",
                "маркированный",
                "таблица",
                "жирный",
                "курсив",
                "выделение",
                "подсветка"
            ];

            // Проверяем наличие триггеров в промпте
            for (const trigger of markdownTriggers) {
                if (lowerPrompt.includes(trigger)) {
                    console.log(`[MARKDOWN_DETECT] Найден триггер "${trigger}" в промпте`);
                    return true;
                }
            }

            console.log("[MARKDOWN_DETECT] Markdown НЕ запрошен - работаем с plain text");
            return false;
        }

        // Extract topic from prompt and generate plan for current article
        async function applyPrompt() {
            // Guard clause: предотвращаем повторные вызовы во время генерации
            if (isGenerating) {
                console.log("[UI] Генерация уже в процессе, игнорирую повторный вызов");
                return;
            }

            try {
                lockApplyButton();

                console.log("[PROMPT] Обработка промпта - НОВАЯ ЛОГИКА С 3 РЕЖИМАМИ");
                const promptText = document.getElementById("promptInput").value.trim();
                console.log(`[PROMPT] Текст промпта: "${promptText}"`);

                if (!promptText) {
                    console.log("[PROMPT] Ошибка: промпт пуст");
                    return;
                }

                // ========== ОПРЕДЕЛЯЕМ РЕЖИМ ПО СОСТОЯНИЮ РЕДАКТОРА ==========
                const modeInfo = detectMode();
                console.log(`[PROMPT] Определен режим: ${modeInfo.mode} (${modeInfo.description})`);

                // ========== ОПРЕДЕЛЯЕМ ФОРМАТ (MARKDOWN или PLAIN TEXT) ==========
                const wantsMarkdown = detectMarkdownRequest(promptText);
                const format = wantsMarkdown ? "markdown" : "plain";
                console.log(`[PROMPT] Формат вывода: ${format}`);

                // ========== РЕЖИМ 1: СОЗДАНИЕ ПЛАНА (текст пуст) ==========
                if (modeInfo.mode === 1) {
                    console.log("[PROMPT] РЕЖИМ 1: весь текст промпта → тема для плана");

                    // Если нет активной статьи - создаём новую
                    if (!currentArticleId) {
                        console.log("[PROMPT] Создаём новую статью для плана");
                        const newArticle = await createEmptyArticleViaAPI(promptText);
                        if (!newArticle) return;
                                addArticleToSidebar(newArticle.id, newArticle.title, true);
                        currentArticleId = newArticle.id;
                    }

                    // Генерируем план
                    showNotification("Генерирую план статьи...");
                    const updatedArticle = await generatePlanForArticleViaAPI(currentArticleId, promptText, format);
                    if (!updatedArticle) return;

                    const titleElem = document.getElementById("titleText");
                    if (titleElem) titleElem.textContent = updatedArticle.title;
                    await typewriterEffect(document.getElementById("editorContent"), updatedArticle.content, 15);
                    updateDirtyState();
                    showNotification("План статьи готов! Теперь можете редактировать текст.");
                }

                // ========== РЕЖИМ 2: ПРАВКА ВСЕГО ТЕКСТА (текст есть, нет выделения) ==========
                else if (modeInfo.mode === 2) {
                    console.log("[PROMPT] РЕЖИМ 2: промпт → инструкция для правки всего текста");

                    if (!currentArticleId) {
                        showNotification("Выберите статью для редактирования");
                        return;
                    }

                    showNotification("Редактирую весь текст...");
                    const oldText = document.getElementById("editorContent").textContent;
                    const updatedArticle = await editFullTextViaAPI(currentArticleId, oldText, promptText, format);
                    if (!updatedArticle) return;


                    // Применяем typewriter effect для замены текста
                    await animateTextReplacement(
                        document.getElementById("editorContent"),
                        oldText,
                        updatedArticle.content,
                        10  // speed
                    );
                    updateDirtyState();

                    // Очищаем подсветку выделения
                    clearSelectionHighlight();
                    savedSelection = null;

                    showNotification("Текст отредактирован!");
                }

                // ========== РЕЖИМ 3: ПРАВКА ФРАГМЕНТА (текст есть + есть выделение) ==========
                else if (modeInfo.mode === 3) {
                    console.log("[PROMPT] РЕЖИМ 3: промпт → инструкция для правки фрагмента");

                    if (!currentArticleId) {
                        showNotification("Выберите статью для редактирования");
                        return;
                    }

                    // Получаем фрагмент с контекстом
                    const selection = getSelectionWithContext();
                    if (!selection) {
                        showNotification("Не удалось получить выделенный текст");
                        return;
                    }

                    showNotification("Редактирую выделенный фрагмент...");
                    const oldText = document.getElementById("editorContent").textContent;
                    const startOffset = savedSelection.startOffset;
                    const endOffset = savedSelection.endOffset;

                    const updatedArticle = await editFragmentViaAPI(
                        currentArticleId,
                        selection.before,
                        selection.fragment,
                        selection.after,
                        promptText,
                        format
                    );
                    if (!updatedArticle) return;


                    // Применяем typewriter effect ТОЛЬКО для фрагмента
                    // Используем новый фрагмент из backend (НЕ из content!)
                    await animateFragmentReplacement(
                        document.getElementById("editorContent"),
                        oldText,
                        startOffset,
                        endOffset,
                        updatedArticle.fragment,
                        10  // speed
                    );
                    updateDirtyState();

                    // Очищаем подсветку выделения
                    clearSelectionHighlight();
                    savedSelection = null;

                    showNotification("Фрагмент отредактирован!");
                }

                    // Очищаем поле промпта
                    document.getElementById("promptInput").value = "";
                    document.getElementById("promptInput").style.height = "auto";
                    console.log("[PROMPT] Процесс завершен успешно");
            } finally {
                unlockApplyButton();
            }
        }

        // Auto-resize textarea (до разумных пределов, потом скролл)
        const promptInput = document.getElementById("promptInput");
        promptInput.addEventListener("input", function() {
            this.style.height = "auto";
            this.style.height = Math.min(this.scrollHeight, 300) + "px";
        });

        // Allow Enter key to submit prompt (Shift+Enter for new line)
        promptInput.addEventListener("keypress", function(e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                applyPrompt();
            }
        });

        // Allow Enter in modal to create article
        document.getElementById("newArticleTitle").addEventListener("keypress", function(e) {
            if (e.key === "Enter") {
                createNewArticle();
            }
        });
    </script>

    <!-- === UNSAVED CHANGES MODAL === -->
    <div class="modal-overlay" id="unsavedChangesModal">
        <div class="modal-content">
            <h3 class="modal-title">Несохранённые изменения</h3>
            <p class="modal-text">У вас есть несохранённые изменения. Они будут потеряны, если вы не сохраните.</p>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" id="modalBtnCancel" onclick="onModalCancel()">Остаться</button>
                <button class="modal-btn modal-btn-discard" id="modalBtnDiscard" onclick="onModalDiscard()">Отбросить</button>
                <button class="modal-btn modal-btn-save" id="modalBtnSave" onclick="onModalSave()">Сохранить</button>
            </div>
        </div>
    </div>
</body>
</html>