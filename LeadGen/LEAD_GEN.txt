# auth.py
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from database import SessionLocal
from models import User

SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

def get_user(db, username: str):
    return db.query(User).filter(User.username == username).first()

def authenticate_user(db, username: str, password: str):
    user = get_user(db, username)
    if not user or not verify_password(password, user.hashed_password):
        return False
    return user

async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    db = SessionLocal()
    user = get_user(db, username)
    db.close()
    if user is None:
        raise credentials_exception
    return user
========================
# monitor.py
from telethon import TelegramClient
from config import API_ID, API_HASH, PHONE, SESSION_NAME
from database import SessionLocal
from models import ChatMonitor
import asyncio
import json

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç (–º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –ø—É–ª –∫–ª–∏–µ–Ω—Ç–æ–≤ –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è)
client = None

async def init_telegram_client():
    global client
    if client is None:
        client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
        await client.start(PHONE)

async def check_chat_for_user(chat_monitor: ChatMonitor):
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–¥–∏–Ω —á–∞—Ç –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    if client is None:
        await init_telegram_client()

    try:
        entity = await client.get_entity(chat_monitor.chat_username)
        current_last_msgs = await client.get_messages(entity, limit=1)
        if not current_last_msgs:
            return chat_monitor.last_message_id

        current_last_id = current_last_msgs[0].id
        if current_last_id <= chat_monitor.last_message_id:
            return chat_monitor.last_message_id

        # –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        messages = await client.get_messages(
            entity,
            limit=None,
            min_id=chat_monitor.last_message_id,
            max_id=current_last_id + 1
        )

        keywords = json.loads(chat_monitor.keywords) if chat_monitor.keywords else []
        new_last_id = chat_monitor.last_message_id

        for msg in reversed(messages):
            text = msg.text or ""
            sender = getattr(msg.sender, 'username', '–∞–Ω–æ–Ω–∏–º') if msg.sender else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
            for keyword in keywords:
                if keyword.lower() in text.lower():
                    # üéØ –ù–ê–ô–î–ï–ù –õ–ò–î!
                    print(f"üéØ –õ–ò–î –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ID {chat_monitor.user_id} –≤ —á–∞—Ç–µ {chat_monitor.chat_username}")
                    print(f"   –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ: '{keyword}'")
                    print(f"   –û—Ç: @{sender}")
                    print(f"   –¢–µ–∫—Å—Ç: {text[:100]}...")

                    # üö® –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–∫—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (email, Telegram –∏ —Ç.–¥.)

            new_last_id = max(new_last_id, msg.id)

        return new_last_id

    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —á–∞—Ç–∞ {chat_monitor.chat_username}: {e}")
        return chat_monitor.last_message_id
============================
import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from fastapi import FastAPI, Depends, Request, Form
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from auth import create_access_token, authenticate_user, get_current_user, get_password_hash
from database import SessionLocal
from models import User, ChatMonitor
from monitor import init_telegram_client, check_chat_for_user
import json
from urllib.parse import urlencode
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram –∫–ª–∏–µ–Ω—Ç–∞ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞
scheduler = AsyncIOScheduler()

@app.on_event("startup")
async def startup_event():
    await init_telegram_client()
    scheduler.add_job(background_monitoring_job, 'interval', seconds=10, coalesce=True, max_instances=1)
    scheduler.start()

@app.on_event("shutdown")
async def shutdown_event():
    scheduler.shutdown()

# –§–æ–Ω–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
async def background_monitoring_job():
    db = SessionLocal()
    monitors = db.query(ChatMonitor).all()
    for monitor in monitors:
        try:
            new_last_id = await check_chat_for_user(monitor)
            monitor.last_message_id = new_last_id
            db.commit()
        except Exception as e:
            print(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∞ ID {monitor.id}: {e}")
    db.close()

# === –†–æ—É—Ç—ã ===

@app.get("/", response_class=HTMLResponse)
async def landing(request: Request):
    return templates.TemplateResponse("landing.html", {"request": request})

# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
@app.get("/register", response_class=HTMLResponse)
async def register_form(request: Request):
    return templates.TemplateResponse("register.html", {"request": request})

@app.post("/register")
async def register(username: str = Form(...), email: str = Form(...), password: str = Form(...)):
    db = SessionLocal()
    hashed_password = get_password_hash(password)
    user = User(username=username, email=email, hashed_password=hashed_password)
    db.add(user)
    db.commit()
    db.close()
    return RedirectResponse(url="/login", status_code=303)

# –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
@app.get("/login", response_class=HTMLResponse)
async def login_form(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

@app.post("/login")
async def login(username: str = Form(...), password: str = Form(...)):
    db = SessionLocal()
    user = authenticate_user(db, username, password)
    db.close()
    if not user:
        query_params = urlencode({"error": "–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å"})
        return RedirectResponse(url=f"/login?{query_params}", status_code=303)
    token = create_access_token(data={"sub": user.username})
    response = RedirectResponse(url="/dashboard", status_code=303)
    response.set_cookie(key="access_token", value=f"Bearer {token}", httponly=True)
    return response

# –î–∞—à–±–æ—Ä–¥
@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request, current_user: User = Depends(get_current_user)):
    db = SessionLocal()

    # –ü–æ–ª—É—á–∞–µ–º —á–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    chats = db.query(ChatMonitor).filter(ChatMonitor.user_id == current_user.id).all()

    # –ü—Ä–∏–º–µ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ (–≤ –±—É–¥—É—â–µ–º ‚Äî –∏–∑ –ë–î)
    stats = {
        "today_leads"      : 24,
        "month_leads"      : 342,
        "conversion_rate"  : "18%",
        "avg_response_time": "12 –º–∏–Ω"
    }

    # –ü—Ä–∏–º–µ—Ä –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –ª–∏–¥–æ–≤ (–≤ –±—É–¥—É—â–µ–º ‚Äî –∏–∑ –ë–î)
    recent_leads = [
        {
            "date"    : "12.04.2023 14:23",
            "name"    : "–ú–∞—Ä–∏—è –ò–≤–∞–Ω–æ–≤–∞",
            "telegram": "@maria_ivanova",
            "source"  : "–ß–∞—Ç '–ù–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç—å –ú–æ—Å–∫–≤—ã'",
            "keyword" : "–∫—É–ø–∏—Ç—å –∫–≤–∞—Ä—Ç–∏—Ä—É",
            "status"  : "–ù–æ–≤—ã–π"
        },
        {
            "date"    : "12.04.2023 13:47",
            "name"    : "–°–µ—Ä–≥–µ–π –ü–µ—Ç—Ä–æ–≤",
            "telegram": "@sergey_petrov",
            "source"  : "–ö–∞–Ω–∞–ª '–ë–∏–∑–Ω–µ—Å –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–∏'",
            "keyword" : "—é—Ä–∏–¥–∏—á–µ—Å–∫–∏–µ —É—Å–ª—É–≥–∏",
            "status"  : "–í —Ä–∞–±–æ—Ç–µ"
        }
    ]

    db.close()

    return templates.TemplateResponse("dashboard.html", {
        "request"     : request,
        "user"        : {
            "username": current_user.username,
            "email"   : current_user.email,
            "tariff"  : current_user.tariff,
            "role"    : "–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º"  # –º–æ–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å –≤ –ë–î
        },
        "stats"       : stats,
        "recent_leads": recent_leads,
        "chats"       : chats
    })

# –î–æ–±–∞–≤–∏—Ç—å —á–∞—Ç
@app.post("/add_chat")
async def add_chat(
    chat_username: str = Form(...),
    keywords: str = Form(...),
    notifications_to: str = Form(...),
    current_user: User = Depends(get_current_user)
):
    db = SessionLocal()
    chat_count = db.query(ChatMonitor).filter(ChatMonitor.user_id == current_user.id).count()
    if chat_count >= current_user.max_chats:
        return {"error": "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —á–∞—Ç–æ–≤"}

    keyword_list = [kw.strip() for kw in keywords.splitlines() if kw.strip()]
    if len(keyword_list) > current_user.max_keywords_per_chat:
        return {"error": "–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤"}

    new_chat = ChatMonitor(
        user_id=current_user.id,
        chat_username=chat_username,
        keywords=json.dumps(keyword_list),
        notifications_to=notifications_to
    )
    db.add(new_chat)
    db.commit()
    db.close()
    return f"""
    <div class="chat-card">
        <h3>{chat_username}</h3>
        <p>–ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞: {', '.join(keyword_list)}</p>
        <p>–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: {notifications_to}</p>
        <button hx-delete="/delete_chat/{new_chat.id}" hx-confirm="–£–¥–∞–ª–∏—Ç—å?">–£–¥–∞–ª–∏—Ç—å</button>
    </div>
    """

# –£–¥–∞–ª–∏—Ç—å —á–∞—Ç
@app.delete("/delete_chat/{chat_id}")
async def delete_chat(chat_id: int, current_user: User = Depends(get_current_user)):
    db = SessionLocal()
    chat = db.query(ChatMonitor).filter(ChatMonitor.id == chat_id, ChatMonitor.user_id == current_user.id).first()
    if chat:
        db.delete(chat)
        db.commit()
    db.close()
    return ""

# –°–º–µ–Ω–∞ —Ç–∞—Ä–∏—Ñ–∞
@app.get("/change_tariff", response_class=HTMLResponse)
async def change_tariff(request: Request, current_user: User = Depends(get_current_user)):
    return "–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å–º–µ–Ω—ã —Ç–∞—Ä–∏—Ñ–∞ ‚Äî –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ"

@app.get("/logout")
async def logout():
    response = RedirectResponse(url="/")
    response.delete_cookie("access_token")
    return response

# –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è –∑–∞–ø—É—Å–∫–∞
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)
===========================
# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# SQLite URL ‚Äî –±–∞–∑–∞ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∞ –≤ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
SQLALCHEMY_DATABASE_URL = "sqlite:///./leadscanner.db"

# –°–æ–∑–¥–∞—ë–º –¥–≤–∏–∂–æ–∫
# check_same_thread=False ‚Äî –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å SQLite –≤ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ (FastAPI + APScheduler)
engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    connect_args={"check_same_thread": False}
)

# –°–æ–∑–¥–∞—ë–º —Ñ–∞–±—Ä–∏–∫—É —Å–µ—Å—Å–∏–π
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# –ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –º–æ–¥–µ–ª–µ–π
Base = declarative_base()


# –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏ –ë–î –≤ —Ä–æ—É—Ç–∞—Ö
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
===========================
from telethon import TelegramClient
from config import API_ID, API_HASH, PHONE, CHAT_ID, SESSION_NAME, CHECK_INTERVAL
import asyncio


async def monitor_chat(client, chat_identifier, last_message_id):
    """–ú–æ–Ω–∏—Ç–æ—Ä–∏—Ç –æ–¥–∏–Ω —á–∞—Ç: –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è, –≤—ã–≤–æ–¥–∏—Ç –∏—Ö, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–æ–≤—ã–π last_message_id"""
    try:
        entity = await client.get_entity(chat_identifier)
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —á–∞—Ç {chat_identifier}. –£–±–µ–¥–∏—Å—å, —á—Ç–æ —Ç—ã –ø–æ–¥–ø–∏—Å–∞–Ω –Ω–∞ –Ω–µ–≥–æ!")
        return last_message_id

    try:
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —ç—Ç–æ–º —á–∞—Ç–µ
        current_last_msgs = await client.get_messages(entity, limit=1)
        if not current_last_msgs:
            print(f"üì≠ –í —á–∞—Ç–µ {chat_identifier} –ø–æ–∫–∞ –Ω–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–π.")
            return last_message_id

        current_last_id = current_last_msgs[0].id

        # –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        if current_last_id > last_message_id:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è –º–µ–∂–¥—É last_message_id –∏ current_last_id (–≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ)
            messages = await client.get_messages(
                entity,
                limit=None,
                min_id=last_message_id,
                max_id=current_last_id + 1
            )

            # –í—ã–≤–æ–¥–∏–º –≤ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–æ–º –ø–æ—Ä—è–¥–∫–µ (–æ—Ç —Å—Ç–∞—Ä—ã—Ö –∫ –Ω–æ–≤—ã–º)
            for msg in reversed(messages):
                text = msg.text or "[–º–µ–¥–∏–∞/—Ñ–∞–π–ª/—Å—Ç–∏–∫–µ—Ä]"
                sender = getattr(msg.sender, 'username', '–∞–Ω–æ–Ω–∏–º') if msg.sender else '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                print(f"\nüì¨ –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç–µ {chat_identifier} [ID {msg.id}] –æ—Ç {msg.date} (–æ—Ç @{sender}):")
                print(f"   {text}")

            # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–π ID –¥–ª—è —ç—Ç–æ–≥–æ —á–∞—Ç–∞
            return current_last_id

        else:
            # print(f"üí§ –í —á–∞—Ç–µ {chat_identifier} –Ω–µ—Ç –Ω–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π.")  # –º–æ–∂–Ω–æ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
            return last_message_id

    except Exception as e:
        print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —á–∞—Ç–∞ {chat_identifier}: {e}")
        return last_message_id


async def main():
    # –ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è
    client = TelegramClient(SESSION_NAME, API_ID, API_HASH)
    await client.start(PHONE)

    print("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω. –ù–∞—á–∏–Ω–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —á–∞—Ç–æ–≤...")

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ª–æ–≤–∞—Ä—å: chat_id ‚Üí last_message_id
    chat_last_ids = {}

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è: –ø–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∞—Ç–∞
    for chat_id in CHAT_ID:
        try:
            entity = await client.get_entity(chat_id)
            last_msgs = await client.get_messages(entity, limit=1)
            if last_msgs:
                chat_last_ids[chat_id] = last_msgs[0].id
                preview_text = last_msgs[0].text or "[–Ω–µ —Ç–µ–∫—Å—Ç]"
                print(f"üìå –ß–∞—Ç {chat_id}: –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ID {chat_last_ids[chat_id]} ‚Äî {preview_text[:50]}...")
            else:
                chat_last_ids[chat_id] = 0
                print(f"üì≠ –ß–∞—Ç {chat_id}: —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–∫–∞ –Ω–µ—Ç.")
        except Exception as e:
            print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —á–∞—Ç {chat_id}: {e}")
            chat_last_ids[chat_id] = 0

    # –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö —á–∞—Ç–æ–≤
    while True:
        for chat_id in CHAT_ID:
            print(f"\nüîç –ü—Ä–æ–≤–µ—Ä—è–µ–º —á–∞—Ç: {chat_id}")
            new_last_id = await monitor_chat(client, chat_id, chat_last_ids[chat_id])
            chat_last_ids[chat_id] = new_last_id

        print(f"\n‚è≥ –°–ø–∏–º {CHECK_INTERVAL} —Å–µ–∫...")
        await asyncio.sleep(CHECK_INTERVAL)


# –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    asyncio.run(main())
=====================




























