# ğŸ¬ Beem Video Engine - ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°

ĞŸĞ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ Ğ½ĞµĞ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ñ‹Ğ¹ Ğ²Ğ¸Ğ´ĞµĞ¾-Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€, Ğ²ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ² Telegram-Ğ±Ğ¾Ñ‚.

## ğŸ—ï¸ ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¿Ğ°Ğ¹Ğ¿Ğ»Ğ°Ğ¹Ğ½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TELEGRAM USER INTERACTION              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  /start command     â”‚
        â”‚  or photo upload    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Telegram UI (aiogram FSM)    â”‚
        â”‚  - Collect photo               â”‚
        â”‚  - Collect text prompt         â”‚
        â”‚  - Confirm generation          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 1                â”‚
        â”‚     Smart Prompt Enhancer                   â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Detect PRESERVE constraints               â”‚
        â”‚ 2. Call GPT-4o-mini for enhancement          â”‚
        â”‚ 3. Translate RU â†’ EN                         â”‚
        â”‚ 4. Add cinematic details                     â”‚
        â”‚ 5. Add NO_GENERATION block (if PRESERVE)    â”‚
        â”‚ Result: prompt_cinematic                     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 2                â”‚
        â”‚     Camera Director Compilation             â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Extract preservation keywords             â”‚
        â”‚ 2. If PRESERVE keywords found:               â”‚
        â”‚    â†’ Use ONLY [Static shot]                  â”‚
        â”‚ 3. Else:                                     â”‚
        â”‚    â†’ Call GPT-4o-mini for camera commands   â”‚
        â”‚ 4. Validate 15 allowed MiniMax commands     â”‚
        â”‚ 5. Sanitize invalid commands                â”‚
        â”‚ Result: prompt_director (with commands)     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 3                â”‚
        â”‚     Queue Management                        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Create QueueItem                          â”‚
        â”‚ 2. Add to queue (FIFO)                       â”‚
        â”‚ 3. Start async processor (concurrency=1)    â”‚
        â”‚ 4. Dequeue when processor available          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 4                â”‚
        â”‚     MiniMax API Call                        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Convert JPEG to base64                    â”‚
        â”‚ 2. POST /video_generation                    â”‚
        â”‚    - first_frame_image: base64              â”‚
        â”‚    - prompt: prompt_director                â”‚
        â”‚    - duration: 6 or 10 secs                 â”‚
        â”‚    - resolution: 768P                       â”‚
        â”‚ 3. Get generation_id from response           â”‚
        â”‚ Result: generation_id (MiniMax task ID)     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 5                â”‚
        â”‚     Status Polling                          â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Loop for max 120 iterations (2 mins)     â”‚
        â”‚ 2. GET /video_generation?task_id=gen_id    â”‚
        â”‚ 3. Check status:                            â”‚
        â”‚    - "processing" â†’ continue polling        â”‚
        â”‚    - "done" â†’ go to Phase 6                 â”‚
        â”‚    - "failed" â†’ error handling              â”‚
        â”‚ 4. Update progress every iteration          â”‚
        â”‚ Result: video_url (download URL)            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       VIDEO ENGINE - PHASE 6                â”‚
        â”‚     Video Download                          â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Download video from video_url            â”‚
        â”‚ 2. Save to /tmp/beem-videos/                 â”‚
        â”‚ 3. Store file path in status                 â”‚
        â”‚ Result: video_path (local file)             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     Telegram Bot - Send Result              â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
        â”‚ 1. Retrieve video_path from engine          â”‚
        â”‚ 2. Send as Telegram video                    â”‚
        â”‚ 3. Offer to create another video            â”‚
        â”‚ 4. Cleanup temp files                        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
            â”‚    DONE    â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Component Relationships

```
main.py (FastAPI entry point)
  â”œâ”€ Starts bot.py in background
  â””â”€ Starts video_engine in background
         â”‚
         â”œâ”€ bot.py (Telegram UI)
         â”‚   â””â”€ Calls video_engine.generate_video()
         â”‚       â”œâ”€ Prompts for photo
         â”‚       â”œâ”€ Prompts for text
         â”‚       â””â”€ Triggers video_engine
         â”‚
         â””â”€ core/video_engine.py (Orchestrator)
             â”œâ”€ core/prompts.py
             â”‚   â””â”€ Uses openai.ChatCompletion (GPT-4o-mini)
             â”‚
             â”œâ”€ core/director.py
             â”‚   â””â”€ Uses openai.ChatCompletion (GPT-4o-mini)
             â”‚
             â”œâ”€ core/minimax.py
             â”‚   â””â”€ Uses aiohttp for MiniMax API
             â”‚
             â”œâ”€ core/queue.py
             â”‚   â””â”€ Manages FIFO queue with asyncio.Lock
             â”‚
             â””â”€ Lifecycle:
                 generate_video() â†’ enqueue â†’ dequeue â†’ process â†’ poll
```

## ğŸ”„ Data Flow

### Input
```
user_id: int          # Telegram user ID
photo_path: str       # Local JPEG file path
prompt_text: str      # Russian text from user (max 2000 chars)
duration: int         # 6 or 10 seconds
```

### Phase 1 Output (Smart Prompt Enhancer)
```
prompt_enhanced: str
Example:
"Beautiful sunset over mountains with birds singing in cinematic 4K.
Camera movement from left to right reveals valley below.
NO_GENERATION: sunset, mountains, birds"
```

### Phase 2 Output (Camera Director)
```
prompt_director: str
Example:
"Beautiful sunset over mountains with birds singing in cinematic 4K.
Camera movement from left to right reveals valley below.
NO_GENERATION: sunset, mountains, birds

[Pan left]
[Push in]"
```

### Phase 3 Output (Queue)
```
QueueItem {
  generation_id: uuid
  user_id: int
  prompt: str (prompt_director)
  photo_path: str
  duration: int
}
```

### Phase 4 Output (MiniMax Call)
```
Response:
{
  "success": true,
  "generation_id": "task_12345",
  "status": "queued",
  "cost": 0.5
}
```

### Phase 5 Output (Polling)
```
Response:
{
  "success": true,
  "generation_id": "task_12345",
  "status": "done",
  "video_url": "https://minimax.xxx/videos/output.mp4"
}
```

### Phase 6 Output (Download)
```
File: /tmp/beem-videos/{generation_id}.mp4
Size: ~50-100 MB
Duration: 6 or 10 seconds
Resolution: 768P
```

## ğŸ” PRESERVE Constraints System

### Detection
```python
# In prompts.py
if "PRESERVE: sunset, mountains" in prompt:
    preserve_keywords = ["sunset", "mountains"]
    add_no_generation_block = True
```

### Storage
```python
# Database would store
{
  "prompt": "original from user",
  "prompt_enhanced": "after GPT",
  "preserve_block": "sunset, mountains",
  "preserve_keywords": ["sunset", "mountains"]
}
```

### Enforcement in Camera Director
```python
# In director.py
if any(keyword in preserve_keywords for keyword in STATIC_ONLY_KEYWORDS):
    camera_commands = "[Static shot]"  # ONLY this command
    # All other commands forbidden
```

### Result in MiniMax Call
```python
prompt_director = """
...
NO_GENERATION: sunset, mountains

[Static shot]
"""
# MiniMax honors NO_GENERATION block
# No blur/DOF on preserved elements
```

## ğŸ¯ Queue System Details

### Concurrency Model
```
- Single processor loop
- Takes ONE item from queue at a time
- Processes fully (all 6 phases)
- Then dequeues next item

Timeline:
User1 â†’ Gen1 queued (queue.size=1)
        Gen1 processing... (2-3 minutes)
User2 â†’ Gen2 queued (queue.size=2)
User3 â†’ Gen3 queued (queue.size=3)
        ...
        Gen1 done
        Gen2 starts processing
        Gen3 waits in queue
```

### Implementation
```python
# asyncio.Lock ensures thread-safe
async def process_queue():
    while True:
        item = await queue.dequeue()  # Locked
        if item:
            await _process_generation(item)  # Takes 2-3 minutes
```

## ğŸ“ Status Tracking

```python
# Stored in memory
_generation_status = {
    "gen_uuid": {
        "status": "processing",  # queued â†’ processing â†’ done â†’ failed
        "user_id": 123456,
        "prompt": "...",
        "prompt_enhanced": "...",
        "prompt_cinematic": "...",
        "minimax_generation_id": "task_xxx",
        "minimax_status": "processing",
        "video_path": "/tmp/beem-videos/gen_uuid.mp4",
        "created_at": datetime,
        "completed_at": datetime
    }
}
```

## ğŸ›¡ï¸ Error Handling

### Level 1: Generation Initiation
```
- Invalid photo path â†’ error response
- No OPENAI_API_KEY â†’ skip enhancement
- No MINIMAX_API_KEY â†’ error response
```

### Level 2: GPT Calls
```
- Timeout (10-12 sec) â†’ use original text
- OpenAI API error â†’ retry with exponential backoff (3 attempts)
- Rate limit â†’ graceful degradation
```

### Level 3: MiniMax Call
```
- HTTP error â†’ error response with message
- No generation_id â†’ cannot continue
- Callback timeout â†’ polling timeout after 120 sec
```

### Level 4: Download
```
- File not found â†’ continue polling
- Download error â†’ retry once
- Local storage full â†’ error message
```

## ğŸ”Œ API Endpoints

### Health Check
```
GET /
GET /health
```

### Debug (development only)
```
GET /debug/state
```

## ğŸ“Š Monitoring & Logs

### Engine Logs
```
[ENGINE] generation_initiated: gen_uuid (user=123456)
[ENGINE] prompt_enhanced: gen_uuid
[ENGINE] camera_selected: gen_uuid
[ENGINE] minimax_request: gen_uuid â†’ task_xxx
[ENGINE] minimax_done: gen_uuid
[ENGINE] Generation complete: gen_uuid
```

### Telegram Logs
```
[TG] user_start: 123456
[TG] user_uploaded_photo: 123456
[TG] user_sent_prompt: 123456
[TG] generation_started: 123456
[TG] generation_polling: 123456 (status=processing)
[TG] generation_complete: 123456
```

## ğŸš€ Deployment Considerations

### Environment
- Python 3.10+
- Async-compatible (uvicorn)
- /tmp directory must exist
- /tmp/beem-videos/ for video storage

### Resources
- CPU: 1+ cores (async I/O bound)
- RAM: 512 MB minimum (1 GB recommended)
- Storage: ~100 MB per video (cleanup after send)
- Network: Outbound HTTPS for OpenAI + MiniMax

### Scalability
- Single Telegram bot instance
- Multiple FastAPI workers possible (separate video engine per worker)
- Queue survives restarts if persisted to DB
- Consider Redis for distributed queue if needed

## ğŸ”® Future Enhancements

1. **Persistent Queue** - Database instead of in-memory
2. **User Analytics** - Track generations per user
3. **Cost Tracking** - Monitor OpenAI + MiniMax spending
4. **Prompt Templates** - Pre-built prompt starters
5. **Video Editing** - Post-processing effects
6. **Retry Logic** - Automatic requeue on failure
7. **Rate Limiting** - Per-user generation limits
8. **Payment Gateway** - Premium generation tiers
